<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>软件开发实践学习记录</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-28T14:36:01.197Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>冰川</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rsa加密</title>
    <link href="http://yoursite.com/2019/06/26/rsa%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2019/06/26/rsa加密/</id>
    <published>2019-06-26T04:17:01.000Z</published>
    <updated>2019-06-28T14:36:01.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非对称加密算法-RSA（三位作者的名字首字母）"><a href="#非对称加密算法-RSA（三位作者的名字首字母）" class="headerlink" title="非对称加密算法 RSA（三位作者的名字首字母）"></a>非对称加密算法 RSA（三位作者的名字首字母）</h2><p>区别于对称加密算法，非对称加密算法采用两种密钥，公钥和私钥，公钥加密，私钥解密，反之也可以。私钥保留，公钥可以公开发布。</p><p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。</p><p>RSA生成密钥的过程用到欧拉函数，模反元素等，十分复杂。</p><ul><li>随机选择两个不相等的质数p和q</li><li>计算p和q的乘积n，上边说的密钥长度，就是n的长度</li><li>计算n的欧拉函数φ(n)</li><li>随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质</li><li>计算e对于φ(n)的模反元素d</li></ul><p>过程虽然复杂，但是一般也不需要特别清楚，我们只需知道计算过程用到了<code>p,q,n,e,d</code>，这些值封装在一起就是私钥，其中n和e封装在一起就是公钥。对计算过程感兴趣的可以看看阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA算法原理（一）</a>和<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA算法原理（二）</a>。</p><p>我们的数据，经过公钥中的n和e进行计算。计算出来的值，可以通过私钥中的n和d反解出来。</p><h2 id="密钥的形式"><a href="#密钥的形式" class="headerlink" title="密钥的形式"></a>密钥的形式</h2><h3 id="ASN-1"><a href="#ASN-1" class="headerlink" title="ASN.1"></a>ASN.1</h3><p>密钥中数据采用<a href="https://zh.wikipedia.org/wiki/ASN.1" target="_blank" rel="noopener">ASN.1</a>结构。ASN.1本身只定义了表示信息的抽象句法，但是没有限定其编码的方法。ASN.1有各种编码规则，其中密钥采用唯一编码规则（DER，Distinguished Encoding Rules）。用ASN.1表示法，公私钥大概是如下形式。</p><p>PublicKey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RSAPublicKey ::= SEQUENCE &#123;</span><br><span class="line">    modulus INTEGER, – n</span><br><span class="line">    publicExponent INTEGER – e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PrivateKey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RSAPrivateKey ::= SEQUENCE &#123;</span><br><span class="line">    version           Version,</span><br><span class="line">    modulus           INTEGER,  -- n</span><br><span class="line">    publicExponent    INTEGER,  -- e</span><br><span class="line">    privateExponent   INTEGER,  -- d</span><br><span class="line">    prime1            INTEGER,  -- p</span><br><span class="line">    prime2            INTEGER,  -- q</span><br><span class="line">    exponent1         INTEGER,  -- d mod (p-1)</span><br><span class="line">    exponent2         INTEGER,  -- d mod (q-1)</span><br><span class="line">    coefficient       INTEGER,  -- (inverse of q) mod p</span><br><span class="line">    otherPrimeInfos   OtherPrimeInfos OPTIONAL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DER-编码介绍"><a href="#DER-编码介绍" class="headerlink" title="DER 编码介绍"></a>DER 编码介绍</h3><p>DER编码会将数据编码成二机制形式。DER使用一种TLV格式来描述数据</p><img src="/2019/06/26/rsa加密/der-tlv-basic.png" title="tlv"><p><img src="rsa%E5%8A%A0%E5%AF%86/der-tlv-basic.png" alt></p><p>如果tag是容器类型，value就是另一组TLV了</p><img src="/2019/06/26/rsa加密/der-tlv-recursive.png" title="tlv-recursive"><p><img src="rsa%E5%8A%A0%E5%AF%86/der-tlv-recursive.png" alt></p><h4 id="tag编码"><a href="#tag编码" class="headerlink" title="tag编码"></a>tag编码</h4><p>tag一般占一个字节。前两位表示class类型，第三位表示原子类型还是结构体类型。</p><img src="/2019/06/26/rsa加密/der-tlv-tagbyte.png" title="tlv-tagbyte"><p><img src="rsa%E5%8A%A0%E5%AF%86/der-tlv-tagbyte.png" alt></p><p>具体类型编码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x01 == BOOLEAN</span><br><span class="line">0x02 == Integer</span><br><span class="line">0x03 == Bit String</span><br><span class="line">0x04 == Octet String</span><br><span class="line">0x05 == NULL</span><br><span class="line">0x06 == Object Identifier</span><br><span class="line"></span><br><span class="line">0x0C == UTF8String</span><br><span class="line">0x13 == PrintableString</span><br><span class="line">0x14 == TeletexString</span><br><span class="line">0x16 == IA5String</span><br><span class="line">0x1E == BMPString</span><br><span class="line"></span><br><span class="line">0x30 == SEQUENCE or SEQUENCE OF</span><br><span class="line">0x31 == SET or SET OF</span><br></pre></td></tr></table></figure><p>说明：所有的这些都是UNIVERSAl类型。因为前两位都是0。1E之前的都是primitive类型，因为第三位都是0。30和31是constructed类型，第三位是1。</p><h4 id="长度的约定"><a href="#长度的约定" class="headerlink" title="长度的约定"></a>长度的约定</h4><p>长度字段标示value字段的长度。如果value字段小于128字节，长度字段占一字节。并且字节第一位是0。如果value字段多于128个字节。那这一字节的第一位设置为1，接下来的位数表示需要几个字节来表示长度字段。</p><img src="/2019/06/26/rsa加密/der-tlv-lengthbyte.png" title="tlv-lengthbyte.png"><p><img src="rsa%E5%8A%A0%E5%AF%86/der-tlv-lengthbyte.png" alt></p><p>说明：为什么以128为界。因为默认情况下以一个字节表达长度，而这个字节的第一位用来标志是否溢出。所以只剩下7位用来表达长度。7位可以表达的最大数字是2的7次方128。所以以128为界。如果不用第一位来标志溢出，虽然可以表达256的长度，但是超过256就无法表达了。</p><h4 id="值的约定"><a href="#值的约定" class="headerlink" title="值的约定"></a>值的约定</h4><p>每个值都有一些特殊说明，全部列举比较繁杂，密钥中主要是用INTEGER类型和SEQUENCE类型，下面我们对这两种值类型进行一些说明。</p><h5 id="INTEGER"><a href="#INTEGER" class="headerlink" title="INTEGER"></a>INTEGER</h5><p>正常情况指定长度中的值就是编码后的值。</p><p>比如： 0x03，编码后为 0x02 0x01 0x03。类型，长度，值，很容易理解。</p><p>但是当一个正数，并且第一位是1的时候，需要做一些标示，来表明这个值是正值。标志很简单，就是在值前面加一个全0字节。</p><p>比如值 0x8F（10001111）首位是1</p><img src="/2019/06/26/rsa加密/der-tlv-integer.png" title="der-tlv-integer"><p><img src="/Users/mengbingchuan/workspace/blog/source/_posts/rsa%E5%8A%A0%E5%AF%86/der-tlv-integer.png" alt></p><p>0x02表明类型是INTEGER，长度两个字节，0x00表示是正数。0x8F就是这个值。</p><h5 id="SEQUENCE"><a href="#SEQUENCE" class="headerlink" title="SEQUENCE"></a>SEQUENCE</h5><p>SEQUENCE 包含一组有序的值。超过128位的情况，按照之前的长度约定走。例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">30 81 9f                             ; SEQUENCE (9f Bytes)</span><br><span class="line">|  30 0d                             ; SEQUENCE (d Bytes)</span><br><span class="line">|  |  |  06 09                       ; OBJECT_ID (9 Bytes)</span><br><span class="line">|  |  |  2a 86 48 86 f7 0d 01 01 01  ; 1.2.840.113549.1.1.1 </span><br><span class="line">|  |  05 00                          ; NULL (0 Bytes)</span><br><span class="line">|  03 81 8d                          ; BIT_STRING (8d Bytes)</span><br><span class="line">|     00</span><br><span class="line">|     30 81 89                       ; SEQUENCE (89 Bytes)</span><br><span class="line">|        02 81 81                    ; INTEGER (81 Bytes)</span><br><span class="line">|        |  00</span><br><span class="line">|        |  8f e2 41 2a 08 e8 51 a8  8c b3 e8 53 e7 d5 49 50</span><br><span class="line">|        |  b3 27 8a 2b cb ea b5 42  73 ea 02 57 cc 65 33 ee</span><br><span class="line">|        |  88 20 61 a1 17 56 c1 24  18 e3 a8 08 d3 be d9 31</span><br><span class="line">|        |  f3 37 0b 94 b8 cc 43 08  0b 70 24 f7 9c b1 8d 5d</span><br><span class="line">|        |  d6 6d 82 d0 54 09 84 f8  9f 97 01 75 05 9c 89 d4</span><br><span class="line">|        |  d5 c9 1e c9 13 d7 2a 6b  30 91 19 d6 d4 42 e0 c4</span><br><span class="line">|        |  9d 7c 92 71 e1 b2 2f 5c  8d ee f0 f1 17 1e d2 5f</span><br><span class="line">|        |  31 5b b1 9c bc 20 55 bf  3a 37 42 45 75 dc 90 65</span><br><span class="line">|        02 03                       ; INTEGER (3 Bytes)</span><br><span class="line">|           01 00 01</span><br></pre></td></tr></table></figure><p>外层SEQUENCE，81表示接下来1个字节表示长度，接下来的字节是9f，所以这个值占9f个字节。</p><p>内层SEQUENCE，0d，表示接下来d个字节是内容。</p><h4 id="密钥的表现形式"><a href="#密钥的表现形式" class="headerlink" title="密钥的表现形式"></a>密钥的表现形式</h4><p>接下来的分析，主要依据上边的编码介绍，可以对照着看。</p><p>密钥一般不是直接以der形式存在，大部分情况都会进行二次编码。比如下面这三个例子。</p><h5 id="openssl生成的私钥"><a href="#openssl生成的私钥" class="headerlink" title="openssl生成的私钥"></a>openssl生成的私钥</h5><p>使用openssl生成一个私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private_rsa.pem  1024</span><br></pre></td></tr></table></figure><p>使用base64解码，生成一个二机制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl   base64  -d  -in private_rsa.pem -out private</span><br></pre></td></tr></table></figure><p>可以用vim查看，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi -b private</span><br></pre></td></tr></table></figure><p>在vim中，将展示改成16进制<code>:%!xxd</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">00000000: 3082 025d 0201 0002 8181 00cc 9cd8 3a75  0..]..........:u</span><br><span class="line">00000010: 7080 3935 302a 3299 645c abbe 71b5 c3dd  p.950*2.d\..q...</span><br><span class="line">00000020: 5e3e 4421 409c 29ff 58c8 ff80 b2e5 6393  ^&gt;D!@.).X.....c.</span><br><span class="line">00000030: 13fe 6576 9f7f be6b 7c3a 80f6 0645 9bfc  ..ev...k|:...E..</span><br><span class="line">00000040: d878 6db5 8022 d929 2492 3f6c e69c 5603  .xm..&quot;.)$.?l..V.</span><br><span class="line">00000050: 46b0 60b1 69a7 4de8 ff40 7061 dc22 b279  F.`.i.M..@pa.&quot;.y</span><br><span class="line">00000060: c5b1 ccc5 d695 72cb 665f eada 0bed 9d27  ......r.f_.....&apos;</span><br><span class="line">00000070: 6e22 66e1 4d51 b3be 3393 2806 ea12 8927  n&quot;f.MQ..3.(....&apos;</span><br><span class="line">00000080: 454c e3a4 a9ca a5b3 80c7 ad02 0301 0001  EL..............</span><br><span class="line">00000090: 0281 800f 179a 9365 4a31 0b07 3350 497f  .......eJ1..3PI.</span><br><span class="line">000000a0: 2af9 f2e9 0f36 1b06 5f07 34bb 472a bda6  *....6.._.4.G*..</span><br><span class="line">000000b0: 4a04 3964 62cd acb4 928a f72c f2c2 d766  J.9db......,...f</span><br><span class="line">000000c0: d238 f67e 2f24 3f47 3d28 54df 485e 49aa  .8.~/$?G=(T.H^I.</span><br><span class="line">000000d0: 513a 4035 a265 02bd eb99 027a 214c 3a32  Q:@5.e.....z!L:2</span><br><span class="line">000000e0: 343b e023 77d2 3c24 4af1 6d12 1c79 5190  4;.#w.&lt;$J.m..yQ.</span><br><span class="line">000000f0: 1cbf 73a9 32b8 e9a7 1daa 5382 2f91 7c2d  ..s.2.....S./.|-</span><br><span class="line">00000100: b440 2c0d 31a4 85ee 72bb 7eae 03fb b895  .@,.1...r.~.....</span><br><span class="line">00000110: e812 8102 4100 e708 c31b 59bd 52cd fe3e  ....A.....Y.R..&gt;</span><br><span class="line">00000120: 130e ec2b 0b30 b983 17d3 843b d483 ba07  ...+.0.....;....</span><br><span class="line">00000130: b46a 911c 9f7e 6df5 9cdc cc04 dfe9 d5cf  .j...~m.........</span><br><span class="line">00000140: 6e8e 7401 5e8d b5d4 cb41 4fa9 1093 d8c4  n.t.^....AO.....</span><br><span class="line">00000150: de0d 4b1e 51b1 0241 00e2 b92a d49d 8ccf  ..K.Q..A...*....</span><br><span class="line">00000160: bf3a f78e 2133 c6db bac4 6af5 4414 d514  .:..!3....j.D...</span><br><span class="line">00000170: 7791 6491 b2e3 a1ca 91e1 d88f 6f1e 1f25  w.d.........o..%</span><br><span class="line">00000180: d42f deb6 5b3e 85c7 b467 df10 7040 3877  ./..[&gt;...g..p@8w</span><br><span class="line">00000190: 205f 3059 c3da 6bf8 bd02 4046 9520 b65c   _0Y..k...@F. .\</span><br><span class="line">000001a0: 6640 c3fa 2690 c000 5aee 2246 aacc 3eac  f@..&amp;...Z.&quot;F..&gt;.</span><br><span class="line">000001b0: a972 b583 c212 d673 dae0 c749 64be 359e  .r.....s...Id.5.</span><br><span class="line">000001c0: 86e6 b993 beb9 b1ff b2e3 663b e4f4 ebd1  ..........f;....</span><br><span class="line">000001d0: 207f 960b a5a9 893a 27db 2102 4100 9527   ......:&apos;.!.A..&apos;</span><br><span class="line">000001e0: b258 bbe9 8646 cd59 4d64 e476 3fda 281c  .X...F.YMd.v?.(.</span><br><span class="line">000001f0: 218d 0f93 7aea 8a79 3a2d 10fa 4095 269a  !...z..y:-..@.&amp;.</span><br><span class="line">00000200: 5d0a 822b 85ac 896d a054 78d6 7422 686f  ]..+...m.Tx.t&quot;ho</span><br><span class="line">00000210: 6496 2479 c14d 47b2 3c6b cfc7 5695 0241  d.$y.MG.&lt;k..V..A</span><br><span class="line">00000220: 00a9 9a8c 20ac a6fb 5a17 8df8 e118 397d  .... ...Z.....9&#125;</span><br><span class="line">00000230: 22bc 706a 47cb 9d11 2f4d a4e5 708c 044d  &quot;.pjG.../M..p..M</span><br><span class="line">00000240: 1f4a 6870 3365 a8df 0c1b 440f 12c7 86de  .Jhp3e....D.....</span><br><span class="line">00000250: 4246 0b99 3c9e f01f 2313 b0bf 894b aaa1  BF..&lt;...#....K..</span><br><span class="line">00000260: 58</span><br></pre></td></tr></table></figure><p>接下来比较长，比较乏味，我将生成的私钥进行了简单的格式处理，我们看看是不是符合ASN.1中对私钥的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># VERSION</span><br><span class="line">0201 00 </span><br><span class="line"></span><br><span class="line"># modulus INTEGER,  -- n</span><br><span class="line">02 8181</span><br><span class="line">00cc 9cd8 3a75</span><br><span class="line">7080 3935 302a 3299 645c abbe 71b5 c3dd 5e3e 4421 409c 29ff 58c8 ff80 b2e5 6393</span><br><span class="line">13fe 6576 9f7f be6b 7c3a 80f6 0645 9bfc d878 6db5 8022 d929 2492 3f6c e69c 5603</span><br><span class="line">46b0 60b1 69a7 4de8 ff40 7061 dc22 b279 c5b1 ccc5 d695 72cb 665f eada 0bed 9d27</span><br><span class="line">6e22 66e1 4d51 b3be 3393 2806 ea12 8927 454c e3a4 a9ca a5b3 80c7 ad</span><br><span class="line"></span><br><span class="line"># publicExponent INTEGER,  -- e 65537</span><br><span class="line">02 0301 0001</span><br><span class="line"></span><br><span class="line"># privateExponent INTEGER,  -- d</span><br><span class="line">0281 80</span><br><span class="line">0f 179a 9365 4a31 0b07 3350 497f 2af9 f2e9 0f36 1b06 5f07 34bb 472a bda6</span><br><span class="line">4a04 3964 62cd acb4 928a f72c f2c2 d766 d238 f67e 2f24 3f47 3d28 54df 485e 49aa</span><br><span class="line">513a 4035 a265 02bd eb99 027a 214c 3a32 343b e023 77d2 3c24 4af1 6d12 1c79 5190</span><br><span class="line">1cbf 73a9 32b8 e9a7 1daa 5382 2f91 7c2d b440 2c0d 31a4 85ee 72bb 7eae 03fb b895 e812 81</span><br><span class="line"></span><br><span class="line"># prime1            INTEGER,  -- p</span><br><span class="line">02 41</span><br><span class="line">00 </span><br><span class="line">e708 c31b 59bd 52cd fe3e 130e ec2b 0b30 b983 17d3 843b d483 ba07</span><br><span class="line">b46a 911c 9f7e 6df5 9cdc cc04 dfe9 d5cf 6e8e 7401 5e8d b5d4 cb41 4fa9 1093 d8c4</span><br><span class="line">de0d 4b1e 51b1 </span><br><span class="line"></span><br><span class="line"># prime2            INTEGER,  -- q</span><br><span class="line">0241 </span><br><span class="line">00</span><br><span class="line">e2 b92a d49d 8ccf bf3a f78e 2133 c6db bac4 6af5 4414 d514</span><br><span class="line">7791 6491 b2e3 a1ca 91e1 d88f 6f1e 1f25 d42f deb6 5b3e 85c7 b467 df10 7040 3877</span><br><span class="line">205f 3059 c3da 6bf8 bd</span><br><span class="line"></span><br><span class="line"># exponent1         INTEGER,  -- d mod (p-1)</span><br><span class="line">02 40</span><br><span class="line">46 9520 b65c</span><br><span class="line">6640 c3fa 2690 c000 5aee 2246 aacc 3eac a972 b583 c212 d673 dae0 c749 64be 359e</span><br><span class="line">86e6 b993 beb9 b1ff b2e3 663b e4f4 ebd1 207f 960b a5a9 893a 27db 21</span><br><span class="line"></span><br><span class="line"># exponent2         INTEGER,  -- d mod (q-1)</span><br><span class="line">02 41</span><br><span class="line">00 </span><br><span class="line">9527 b258 bbe9 8646 cd59 4d64 e476 3fda 281c 218d 0f93 7aea 8a79 3a2d 10fa 4095 269a</span><br><span class="line">5d0a 822b 85ac 896d a054 78d6 7422 686f 6496 2479 c14d 47b2 3c6b cfc7 5695 </span><br><span class="line"></span><br><span class="line"># coefficient       INTEGER,  -- (inverse of q) mod p</span><br><span class="line">0241</span><br><span class="line">00</span><br><span class="line">a9 9a8c 20ac a6fb 5a17 8df8 e118 397d 22bc 706a 47cb 9d11 2f4d a4e5 708c 044d</span><br><span class="line">1f4a 6870 3365 a8df 0c1b 440f 12c7 86de 4246 0b99 3c9e f01f 2313 b0bf 894b aaa1 58</span><br></pre></td></tr></table></figure><p>可以看到，私钥中的数据在这里面有完整的对应。</p><h5 id="服务端给的公钥，待补充：这个公钥的类型是什么？"><a href="#服务端给的公钥，待补充：这个公钥的类型是什么？" class="headerlink" title="服务端给的公钥，待补充：这个公钥的类型是什么？"></a>服务端给的公钥，待补充：这个公钥的类型是什么？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCBzf/UKYSGEZNn0ziH8ZhcSmIJ</span><br><span class="line">bVIzGx95BW2URGzpuNDUbdX55mOMPO9Arw/j5zh1kPG5fVq0BcZMFkYhIOn4+6kj</span><br><span class="line">awVpjnNzCvvj2//csftaKyyFslvKPf1Gu3kd/OTVKg93L0kL+SFmPtqI1RT6HUqK</span><br><span class="line">4N6Ht24bia11kkgnewIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><p>格式化后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3081 9f //9f长度的SEQUENCE数据</span><br><span class="line">30 0d   //d 长度的SEQUENCE数据</span><br><span class="line">06 09 2a 8648 86f7 0d01 0101 //9 长度的 Object Identifier数据 1.2.840.113549.1.1.1</span><br><span class="line">0500 //结尾的NULL</span><br><span class="line">0381 8d  //8d长度的 Bit String 数据</span><br><span class="line">00 </span><br><span class="line">3081 8902 8181 0081 cdff</span><br><span class="line">d429 8486 1193 67d3 3887 f198 5c4a 6209</span><br><span class="line">6d52 331b 1f79 056d 9444 6ce9 b8d0 d46d</span><br><span class="line">d5f9 e663 8c3c ef40 af0f e3e7 3875 90f1</span><br><span class="line">b97d 5ab4 05c6 4c16 4621 20e9 f8fb a923</span><br><span class="line">6b05 698e 7373 0afb e3db ffdc b1fb 5a2b</span><br><span class="line">2c85 b25b ca3d fd46 bb79 1dfc e4d5 2a0f</span><br><span class="line">772f 490b f921 663e da88 d514 fa1d 4a8a</span><br><span class="line">e0de 87b7 6e1b 89ad 7592 4827 7b02 0301 </span><br><span class="line">00 01</span><br></pre></td></tr></table></figure><p>头信息很长，首先是一个SEQUNENCE开头，里面有一个SEQUNENCE和一个Bit String。</p><p>内部的这个SEQUNENCE包装了两个数据，一个对象标识，一个空数据结尾，这个对象标识解出来是<code>1.2.840.113549.1.1.1</code>,对应的名字是<code>szOID_RSA_RSA</code>。这是加密算法标识符，有很多类型，这个类型表示，RSA既可以用于加密，也可以用于给数据签名。详细信息可以<a href="https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/ns-wincrypt-_crypt_algorithm_identifier" target="_blank" rel="noopener">参考</a>。</p><p>Bit String中放的数据就是我们的公钥了，下面看看这个公钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">30 81 89</span><br><span class="line"></span><br><span class="line">02 81 81 </span><br><span class="line">0081 cdff</span><br><span class="line">d429 8486 1193 67d3 3887 f198 5c4a 6209</span><br><span class="line">6d52 331b 1f79 056d 9444 6ce9 b8d0 d46d</span><br><span class="line">d5f9 e663 8c3c ef40 af0f e3e7 3875 90f1</span><br><span class="line">b97d 5ab4 05c6 4c16 4621 20e9 f8fb a923</span><br><span class="line">6b05 698e 7373 0afb e3db ffdc b1fb 5a2b</span><br><span class="line">2c85 b25b ca3d fd46 bb79 1dfc e4d5 2a0f</span><br><span class="line">772f 490b f921 663e da88 d514 fa1d 4a8a</span><br><span class="line">e0de 87b7 6e1b 89ad 7592 4827 7b</span><br><span class="line"></span><br><span class="line">02 03 </span><br><span class="line">01 00 01</span><br></pre></td></tr></table></figure><p>以SEQUNENCE作为容器，里面有两个Integer，一个是129个字节的n，一个是e 65537。</p><h5 id="sshkeygen生成的公钥"><a href="#sshkeygen生成的公钥" class="headerlink" title="sshkeygen生成的公钥"></a>sshkeygen生成的公钥</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00000000: 0000 0007 7373 682d 7273 6100 0000 0301  ....ssh-rsa.....</span><br><span class="line">00000010: 0001 0000 0101 00a0 f5d6 20a3 2ff7 6106  .......... ./.a.</span><br><span class="line">00000020: d301 e98a d7a8 6307 bc30 74e8 5668 d7b0  ......c..0t.Vh..</span><br><span class="line">00000030: 80a8 0f8d c1c0 c495 53f4 e016 ec17 26d1  ........S.....&amp;.</span><br><span class="line">00000040: 1635 bfe6 0a60 6174 1a9c dcef 176e 0fb7  .5...`at.....n..</span><br><span class="line">00000050: bd66 a939 25ce 1a56 c446 e3c5 1c31 b894  .f.9%..V.F...1..</span><br><span class="line">00000060: c17f db57 bd4e 88bc b3a8 5c95 919c 2394  ...W.N....\...#.</span><br><span class="line">00000070: 39d0 254b ecac 94fb 7d69 ec1c 143a 434f  9.%K....&#125;i...:CO</span><br><span class="line">00000080: d6a8 4572 eaf6 aef3 3d5e 7899 4ba5 739d  ..Er....=^x.K.s.</span><br><span class="line">00000090: 45d6 d928 b506 93fd 41ae d3f8 1149 92ac  E..(....A....I..</span><br><span class="line">000000a0: f483 a853 22cc ac09 ee5f 76ff 36b6 0424  ...S&quot;...._v.6..$</span><br><span class="line">000000b0: 2dce 9ea1 be1b 92aa 73b6 f1cf 22dc f304  -.......s...&quot;...</span><br><span class="line">000000c0: e146 50ad 472d 4885 9d67 160c fac7 b2e8  .FP.G-H..g......</span><br><span class="line">000000d0: 915b 925c 979f 54b3 2934 269d 28e2 e88b  .[.\..T.)4&amp;.(...</span><br><span class="line">000000e0: 202d c95c a8c8 66af 5784 6cf2 269e abc6   -.\..f.W.l.&amp;...</span><br><span class="line">000000f0: 1bf0 5531 66a4 72fc d10b 9237 00e0 9b17  ..U1f.r....7....</span><br><span class="line">00000100: d2ab 7bf0 a135 0b37 d399 6731 eb83 6f2e  ..&#123;..5.7..g1..o.</span><br><span class="line">00000110: a49c 84c0 9781 63</span><br></pre></td></tr></table></figure><p>这个有点尴尬，好像不是der的编码格式。而且，第一行还显示出了ssh-rsa。这个格式没找到对应的编码介绍，网上有人翻译，看翻译过程，这个编码格式像是简化了的der。可能因为信息类型确定，长度也相对确定，所以省掉了tag，以及长度溢出的措施，这里应该是LV格式，即长度-值。长度占4个字节。我们用这个规则看一下上面的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000 0007 //长度 7</span><br><span class="line">7373 682d 7273 61 //ascii码：ssh-rsa</span><br><span class="line">0000 0003  //长度 3</span><br><span class="line">010001     // e 65537</span><br><span class="line">0000 0101  //长度256</span><br><span class="line">//下面的256个字节，n</span><br><span class="line">00 a0 f5d6 20a3 2ff7 6106</span><br><span class="line">d301 e98a d7a8 6307 bc30 74e8 5668 d7b0</span><br><span class="line">80a8 0f8d c1c0 c495 53f4 e016 ec17 26d1</span><br><span class="line">1635 bfe6 0a60 6174 1a9c dcef 176e 0fb7</span><br><span class="line">bd66 a939 25ce 1a56 c446 e3c5 1c31 b894</span><br><span class="line">c17f db57 bd4e 88bc b3a8 5c95 919c 2394</span><br><span class="line">39d0 254b ecac 94fb 7d69 ec1c 143a 434f</span><br><span class="line">d6a8 4572 eaf6 aef3 3d5e 7899 4ba5 739d</span><br><span class="line">45d6 d928 b506 93fd 41ae d3f8 1149 92ac</span><br><span class="line">f483 a853 22cc ac09 ee5f 76ff 36b6 0424</span><br><span class="line">2dce 9ea1 be1b 92aa 73b6 f1cf 22dc f304</span><br><span class="line">e146 50ad 472d 4885 9d67 160c fac7 b2e8</span><br><span class="line">915b 925c 979f 54b3 2934 269d 28e2 e88b</span><br><span class="line">202d c95c a8c8 66af 5784 6cf2 269e abc6</span><br><span class="line">1bf0 5531 66a4 72fc d10b 9237 00e0 9b17</span><br><span class="line">d2ab 7bf0 a135 0b37 d399 6731 eb83 6f2e</span><br><span class="line">a49c 84c0 9781 63</span><br></pre></td></tr></table></figure><p>这个数据表达了三个信息，类型ssh-rsa，e 65537，n那一大串数。</p><p>ssh-keygen生成的公钥id_rsa.pub，可以通过命令<code>ssh-keygen -f key.pub -e -m pem</code>转成标准der格式。</p><p>比如上面那个公钥经过这个命令之后是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00000000: 3082 010a 0282 0101 00a0 f5d6 20a3 2ff7  0........... ./.</span><br><span class="line">00000010: 6106 d301 e98a d7a8 6307 bc30 74e8 5668  a.......c..0t.Vh</span><br><span class="line">00000020: d7b0 80a8 0f8d c1c0 c495 53f4 e016 ec17  ..........S.....</span><br><span class="line">00000030: 26d1 1635 bfe6 0a60 6174 1a9c dcef 176e  &amp;..5...`at.....n</span><br><span class="line">00000040: 0fb7 bd66 a939 25ce 1a56 c446 e3c5 1c31  ...f.9%..V.F...1</span><br><span class="line">00000050: b894 c17f db57 bd4e 88bc b3a8 5c95 919c  .....W.N....\...</span><br><span class="line">00000060: 2394 39d0 254b ecac 94fb 7d69 ec1c 143a  #.9.%K....&#125;i...:</span><br><span class="line">00000070: 434f d6a8 4572 eaf6 aef3 3d5e 7899 4ba5  CO..Er....=^x.K.</span><br><span class="line">00000080: 739d 45d6 d928 b506 93fd 41ae d3f8 1149  s.E..(....A....I</span><br><span class="line">00000090: 92ac f483 a853 22cc ac09 ee5f 76ff 36b6  .....S&quot;...._v.6.</span><br><span class="line">000000a0: 0424 2dce 9ea1 be1b 92aa 73b6 f1cf 22dc  .$-.......s...&quot;.</span><br><span class="line">000000b0: f304 e146 50ad 472d 4885 9d67 160c fac7  ...FP.G-H..g....</span><br><span class="line">000000c0: b2e8 915b 925c 979f 54b3 2934 269d 28e2  ...[.\..T.)4&amp;.(.</span><br><span class="line">000000d0: e88b 202d c95c a8c8 66af 5784 6cf2 269e  .. -.\..f.W.l.&amp;.</span><br><span class="line">000000e0: abc6 1bf0 5531 66a4 72fc d10b 9237 00e0  ....U1f.r....7..</span><br><span class="line">000000f0: 9b17 d2ab 7bf0 a135 0b37 d399 6731 eb83  ....&#123;..5.7..g1..</span><br><span class="line">00000100: 6f2e a49c 84c0 9781 6302 0301 0001       o.......c.....</span><br></pre></td></tr></table></figure><p>这个就很熟悉了，标准的TLV格式。SEQUNENCE下两个INTEGER，n和e。</p><h4 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h4><p>密钥的格式只见到过这几种，就对这几种进行了分析。还需要看看总共有多少种，如何分类，以及为什么这么分类。</p><p><strong>参考</strong></p><p><a href="http://github.tiankonguse.com/blog/2017/07/01/ASN1-SRA.html" target="_blank" rel="noopener">解读RSA公钥私钥储存格式</a></p><p><a href="https://stackoverflow.com/questions/12749858/rsa-public-key-format" target="_blank" rel="noopener">stackoverflow</a></p><p><a href="https://blog.oddbit.com/post/2011-05-08-converting-openssh-public-keys/" target="_blank" rel="noopener">CONVERTING OPENSSH PUBLIC KEYS</a></p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/seccertenroll/distinguished-encoding-rules" target="_blank" rel="noopener">DER 编码</a></p><p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA 算法原理</a></p><p><a href="https://serverfault.com/questions/9708/what-is-a-pem-file-and-how-does-it-differ-from-other-openssl-generated-key-file" target="_blank" rel="noopener">各类证书格式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非对称加密算法-RSA（三位作者的名字首字母）&quot;&gt;&lt;a href=&quot;#非对称加密算法-RSA（三位作者的名字首字母）&quot; class=&quot;headerlink&quot; title=&quot;非对称加密算法 RSA（三位作者的名字首字母）&quot;&gt;&lt;/a&gt;非对称加密算法 RSA（三位作者的
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS内存介绍</title>
    <link href="http://yoursite.com/2019/03/23/iOS%E5%86%85%E5%AD%98%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/03/23/iOS内存介绍/</id>
    <published>2019-03-23T05:00:23.000Z</published>
    <updated>2019-06-25T09:05:14.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>iOS 启动，会先在内存空间中开辟一块区域，然后将这块区域内部划分成如下部分。</p><img src="/2019/03/23/iOS内存介绍/memory.png" title="This is an example image"><p>图中与我们相关性较大的是栈区和堆区。栈区一般是存放方法栈。堆区存放开发者创建的对象。通常我们说的内存管理，就是指的堆中的内存管理。</p><h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>iOS中采用引用计数的方式管理内存，每多一个强引用，引用计数就加一，销毁一个强引用，引用计数就减一。引用计数为0时，会触发dealloc方法，释放该对象。下面将要介绍的东西都是在引用技术基础上做的内存管理。</p><h1 id="内存相关结构与操作"><a href="#内存相关结构与操作" class="headerlink" title="内存相关结构与操作"></a>内存相关结构与操作</h1><h2 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h2><p>引用计数涉及到的数据结构有isa指针，sidetables，sidetable，weaktable等。</p><p>isa指针中有几位是用来存储该对象被引用的次数的。但是因为位数有限，能表达的数量很有限，当不够表达时，isa中还有一位用来标记是否额外存储。如果标记是1，表示该对象的引用计数还存储在sidetables中。</p><p>sidetables由64个sidetable组成。通过hash算法定位。因为这些表是全局共享，会频繁的并发读写，如果只有一个表，多个线程同时操作时，要等很久。分表后可以大大减少多个线程同时操作一个表的情况，提高性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保证原子操作的自旋锁</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    <span class="comment">// 引用计数的 hash 表</span></span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="comment">// weak 引用全局 hash 表</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用计数表以对象指针为key，以引用计数+两个标记位 为value。因为后两个标记位所以，当引用计数需要加减的时候，是从第三位开始。</p><p>weak表以对象指针为key，以引用地址的数组为key，没增加一个weak引用，就添加到这个数组中。</p><p>retain，relase等相关的操作都是针对这些结构的添加修改删除。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><strong>retainCount</strong></p><p>retainCount比较简单，根据对象地址找到sidetable，然后继续在RefCountmap中找到计数并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> refcnt_result = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">return</span> refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>retain</strong><br>retain操作会对引用计数加1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">table.lock();</span><br><span class="line">size_t&amp; refcntStorage = table.refcnts[this];</span><br><span class="line">if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">&#125;</span><br><span class="line">table.unlock();</span><br><span class="line"></span><br><span class="line">return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release 自动引用减一，减到0，会调用SEL_dealloc，触发dealloc。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release(bool performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">bool do_dealloc = false;</span><br><span class="line"></span><br><span class="line">table.lock();</span><br><span class="line">RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">if (it == table.refcnts.end()) &#123;</span><br><span class="line">do_dealloc = true;</span><br><span class="line">table.refcnts[this] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">&#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&apos;t change it.</span><br><span class="line">do_dealloc = true;</span><br><span class="line">it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">&#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">&#125;</span><br><span class="line">table.unlock();</span><br><span class="line">if (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">&#125;</span><br><span class="line">return do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dealloc 注释有说明，如果没有额外处理，就直接free，不然先通过object_dispose处理若引用，关联属性等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">assert(!UseGC);</span><br><span class="line">if (isTaggedPointer()) return;</span><br><span class="line"></span><br><span class="line">//指针型isa &amp;&amp; 没被弱引用&amp;&amp;没有关联属性&amp;&amp;没有c++创建&amp;&amp;没有用引用计数表</span><br><span class="line">if (isa.indexed  &amp;&amp;  </span><br><span class="line">!isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">!isa.has_assoc  &amp;&amp;  </span><br><span class="line">!isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">!isa.has_sidetable_rc)</span><br><span class="line">&#123;</span><br><span class="line">assert(!sidetable_present());</span><br><span class="line">//直接释放</span><br><span class="line">free(this);</span><br><span class="line">&#125; </span><br><span class="line">else &#123;</span><br><span class="line">object_dispose((id)this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispose会调用destructInstance，这个方法如下，注释有说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">if (obj) &#123;</span><br><span class="line">// Read all of the flags at once for performance.</span><br><span class="line">bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class="line">bool dealloc = !UseGC;</span><br><span class="line"></span><br><span class="line">// This order is important.</span><br><span class="line">//调用c++的销毁方法</span><br><span class="line">if (cxx) object_cxxDestruct(obj);</span><br><span class="line">//移除关联属性</span><br><span class="line">if (assoc) _object_remove_assocations(obj);</span><br><span class="line">//清理引用计数表和weak表</span><br><span class="line">if (dealloc) obj-&gt;clearDeallocating();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是clearDeallocating，主要是处理引用计数表和弱引用表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">if (!isa.indexed) &#123;</span><br><span class="line">// Slow path for raw pointer isa.</span><br><span class="line">//清理引用计数表</span><br><span class="line">sidetable_clearDeallocating();</span><br><span class="line">&#125;</span><br><span class="line">else if (isa.weakly_referenced  ||  isa.has_sidetable_rc) &#123;</span><br><span class="line">// Slow path for non-pointer isa with weak refs and/or side table data.</span><br><span class="line">clearDeallocating_slow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h1><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><p>autoreleasepool通过<code>AutoreleasePoolPage</code>管理对象，每个线程有一个page，存储在TLS中。page内部以栈的方式组织，大小位4096字节，对应操作系统的内存页。每次添加对象就通过page的压栈存入，存满会创建一个新的page继续存储，page与page通过链表的方式存储。push操作会将一个哨兵（nil）压栈，并返回这个位置的地址。pop会查找这个地址，将栈顶到该位置的对象都release。多次的autoreleasepool，会有多个push，记录多个哨兵的位置，然后pop时pop到对应的位置。</p><h2 id="autoreleasepool的实现"><a href="#autoreleasepool的实现" class="headerlink" title="autoreleasepool的实现"></a>autoreleasepool的实现</h2><p>我们通常使用自动释放池就是使用<code>@autoreleasepool{}</code>，这个block对应一个结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">__AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构题会在初始化的时候调用<code>objc_autoreleasePoolPush</code>，在析构时调用<code>objc_autoreleasePoolPop</code>。我们在objc源码中找到这两个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">if (UseGC) return nil;</span><br><span class="line">return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">if (UseGC) return;</span><br><span class="line">AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是<code>AutoreleasePoolPage</code>这个类来实现的。<br>直接从这两个方法看起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//添加哨兵POOL_SENTINEL（值为nil），处理page，返回哨兵对象的地址。</span><br><span class="line">static inline void *push() </span><br><span class="line">&#123;</span><br><span class="line">id *dest;</span><br><span class="line">if (DebugPoolAllocation) &#123;</span><br><span class="line">// Each autorelease pool starts on a new pool page.</span><br><span class="line">dest = autoreleaseNewPage(POOL_SENTINEL);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dest = autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">&#125;</span><br><span class="line">assert(*dest == POOL_SENTINEL);</span><br><span class="line">return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下怎么处理的poolpage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">AutoreleasePoolPage *page = hotPage();</span><br><span class="line">if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">return page-&gt;add(obj);</span><br><span class="line">&#125; else if (page) &#123;</span><br><span class="line">return autoreleaseFullPage(obj, page);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return autoreleaseNoPage(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到当前page，如果能拿到并且，page没有存满，就将obj存入<br>如果page是满的，就走autoreleaseFullPage<br>如果没拿到page，走autoreleaseNoPage方法</p><p>接着看下hotPage()是怎么处理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline AutoreleasePoolPage *hotPage() </span><br><span class="line">&#123;</span><br><span class="line">AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">tls_get_direct(key);</span><br><span class="line">if (result) result-&gt;fastcheck();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个page是放到线程的存储空间的，所以poolpage是线程相关的，一个线程，一个page链。</p><p>没有page时，第一次创建成功会将hotpage存起来，会存到线程中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void setHotPage(AutoreleasePoolPage *page) </span><br><span class="line">&#123;</span><br><span class="line">if (page) page-&gt;fastcheck();</span><br><span class="line">tls_set_direct(key, (void *)page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此push就差不多了，总结下push都干了什么</p><ul><li>从线程的存储空间中拿到当前页（hotpage），没有的话，就创建一个放进去</li><li>查看page有没有满，没满就将传入的哨兵存入。</li><li>page满了，向链中寻找最后一个节点，创建一个新的page，parent设置为这个节点，将这个节点设置为hotpage。</li></ul><p>接下来看看pop</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static inline void pop(void *token) </span><br><span class="line">&#123;</span><br><span class="line">AutoreleasePoolPage *page;</span><br><span class="line">id *stop;</span><br><span class="line">//token是一个地址，要pop到这个地址为止。</span><br><span class="line">//找到这个地址所在的page</span><br><span class="line">page = pageForPointer(token);</span><br><span class="line">stop = (id *)token;</span><br><span class="line">//释放对象到指定的地址</span><br><span class="line">page-&gt;releaseUntil(stop);</span><br><span class="line">//移除空的page</span><br><span class="line">// memory: delete empty children</span><br><span class="line">if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">// special case: delete everything during page-per-pool debugging</span><br><span class="line">AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">page-&gt;kill();</span><br><span class="line">//重置hotpage</span><br><span class="line">setHotPage(parent);</span><br><span class="line">&#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">// special case: delete everything for pop(top) </span><br><span class="line">// when debugging missing autorelease pools</span><br><span class="line">//删光了，就没了</span><br><span class="line">page-&gt;kill();</span><br><span class="line">setHotPage(nil);</span><br><span class="line">&#125; </span><br><span class="line">else if (page-&gt;child) &#123;</span><br><span class="line">//如果当前page已经用了超过一半了，就保留一个空的page</span><br><span class="line">// hysteresis: keep one empty child if page is more than half full</span><br><span class="line">if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">page-&gt;child-&gt;kill();</span><br><span class="line">&#125;</span><br><span class="line">else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop操作和push是成对操作，push操作记录的位置，接下来会用来pop。</p><h2 id="runtime对autorelease返回值的优化"><a href="#runtime对autorelease返回值的优化" class="headerlink" title="runtime对autorelease返回值的优化"></a>runtime对autorelease返回值的优化</h2><p><strong>问题1:为什么要做这个优化？</strong></p><p>答：<br>当返回值被返回之后，紧接着就需要被 retain 的时候，没有必要进行 autorelease + retain，直接什么都不要做就好了。</p><p><strong>问题2:如何做的优化？</strong></p><p>基本思路：</p><p>在返回值身上调用<code>objc_autoreleaseReturnValue</code>方法时，runtime在TLS中做一个标记，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的objc_retainAutoreleasedReturnValue里，发现TLS中有标记，那么直接返回这个object（不调用retain）。<br>于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。</p><p>具体做法：<br>优化主要是通过两个方法进行实现<code>objc_autoreleaseReturnValue</code>和<code>objc_retainAutoreleasedReturnValue</code></p><p>看第一个方法前，先看个枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum ReturnDisposition : bool &#123;</span><br><span class="line">ReturnAtPlus0 = false, ReturnAtPlus1 = true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>objc_autoreleaseReturnValue</code></strong></p><p>方法的实现如下，通过注释进行了解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Prepare a value at +1 for return through a +0 autoreleasing convention.</span><br><span class="line">id objc_autoreleaseReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">//可被优化的场景下，直接返回obj</span><br><span class="line">if (prepareOptimizedReturn(ReturnAtPlus1)) return obj;</span><br><span class="line">//否则还是使用autorelease</span><br><span class="line">return objc_autorelease(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对可优化场景的判断，在<code>prepareOptimizedReturn</code>方法中，参数我们根据上边的枚举已经得知<br><code>ReturnAtPlus1</code>是<code>true</code>,看下这个方法的实现，用注释做了说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE bool </span><br><span class="line">prepareOptimizedReturn(ReturnDisposition disposition)</span><br><span class="line">&#123;</span><br><span class="line">//如果调用方符合优化条件，就返回true，表示这次调用可以被优化</span><br><span class="line">if (callerAcceptsOptimizedReturn(__builtin_return_address(0))) &#123;</span><br><span class="line">//设置dispostion，为后续的objc_retainAutoreleasedReturnValue准备</span><br><span class="line">if (disposition) setReturnDisposition(disposition);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">//不符合条件，不做优化</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setReturnDisposition</code>是在TLS中存入标记，后续的<code>objc_retainAutoreleasedReturnValue</code>会从TLS中读取来判断，之前是否已经做过了优化。这里比较复杂的方法是<code>callerAcceptsOptimizedReturn</code>判断调用方是否接受一个优化的结果。方法的实现比较难以理解，但是注释说明的比较清楚。</p><blockquote><p>Callee looks for <code>mov rax, rdi</code> followed by a call or<br>jump instruction to objc_retainAutoreleasedReturnValue or<br>objc_unsafeClaimAutoreleasedReturnValue. </p></blockquote><p>接收方为上述的两种情况时，调用方就符合优化条件。这个条件其实是判断，是否MRC和ARC混编，如果调用方和被调方一个使用MRC一个使用ARC，就不能做这个优化了。</p><p><strong><code>objc_retainAutoreleasedReturnValue</code></strong></p><p>这个方法相对简单，就是判断之前是否已经做了优化（通过TLS中的<code>RETURN_DISPOSITION_KEY</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Accept a value returned through a +0 autoreleasing convention for use at +1.</span><br><span class="line">id objc_retainAutoreleasedReturnValue(id obj)</span><br><span class="line">&#123;   //从TLS中获取RETURN_DISPOSITION_KEY对应的值，为true，就直接返回obj。</span><br><span class="line">//读取完之后，重置为false</span><br><span class="line">if (acceptOptimizedReturn() == ReturnAtPlus1) return obj;</span><br><span class="line">//没有优化，就走正常的retain流程</span><br><span class="line">return objc_retain(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法成对使用，就可以省去将对象添加到autoreleasepool中的操作。</p><h1 id="一个对象的内存布局"><a href="#一个对象的内存布局" class="headerlink" title="一个对象的内存布局"></a>一个对象的内存布局</h1><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><code>alloc</code> <code>init</code>分别做了些什么事？</p><p>一个类的alloc方法，会向堆申请一块区域，用来存储对象中的变量。接下来看看对象中的变量组成。</p><p>OC类会被转成struct来表示，一个NSObject转成struct是下面这个样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p>Class是一个别名，它其实是 object_class指针。</p><p>一个自定义类的表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject&#123;</span><br><span class="line"></span><br><span class="line">@public</span><br><span class="line">int _no;</span><br><span class="line">int _age;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">struct Student_IMPL &#123;</span><br><span class="line">struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">int _no;</span><br><span class="line">int _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以子类的实例变量中的第一个是父类struct表示。那么一个类分配的内存，是父类变量的内存，加上本类变量需要的内存。最顶部的NSObject中只有一个isa指针，而指针的大小与操作系统的位数有关，64位，指针也是64位，8个字节。32位，指针也是32位，4个字节。以64位系统为例，NSObject的对象会占用8个字节。Student会占用16个字节。</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>一个对象占用的内存，并不是所有变量相加出来的结果。中间会有一些空位补0，来对齐。目的是为了提高内存的访问效率以及平台移植。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct StructOne &#123;</span><br><span class="line">char a;         //1字节</span><br><span class="line">double b;       //8字节</span><br><span class="line">int c;          //4字节</span><br><span class="line">short d;        //2字节</span><br><span class="line">&#125; MyStruct1;</span><br><span class="line"></span><br><span class="line">struct StructTwo &#123;</span><br><span class="line">double b;       //8字节</span><br><span class="line">char a;         //1字节</span><br><span class="line">short d;        //2字节</span><br><span class="line">int c;         //4字节</span><br><span class="line">&#125; MyStruct2;</span><br><span class="line">NSLog(@&quot;%lu---%lu--&quot;, sizeof(MyStruct1), sizeof(MyStruct2));</span><br><span class="line">//24,16</span><br></pre></td></tr></table></figure><p>两个结构体中的组成一样，内存占用却不一样。先看下原则</p><p>内存对齐原则：</p><ul><li>对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍</li><li>结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍</li><li>如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型</li></ul><p>在不设置pragma pack的情况下，我们用前两条原则，对上面两个结构体进行分析。<br>StructOne</p><ul><li>a字段从0起，占一个字节，offset1</li><li>b字段不能从2起，按照原则1，要从8开始，占8个字节，offset 16</li><li>c字段从16起，没有问题，占4个字节，offset 20</li><li>d字段从20起，没有问题，占2个字节，offset 22</li><li>根据原则2，structOne的占位应该是double类型的整数倍，22最近的8的倍数，即24。</li></ul><p>-&gt;操作<br>地址操作，通过</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="内存bug调试，zombie模式，address-sanitizer，instruments"><a href="#内存bug调试，zombie模式，address-sanitizer，instruments" class="headerlink" title="内存bug调试，zombie模式，address sanitizer，instruments"></a>内存bug调试，zombie模式，address sanitizer，instruments</h2><p>待了解：<br><a href="https://developer.apple.com/videos/play/wwdc2018/416/" target="_blank" rel="noopener">iOS Memory Deep Dive</a></p><p>补充：<br>NSNumber，NSDate 使用taggedPointer技术，将指针与值保存在一起。看似对象，其实是基础类型。存在栈中，不会放到堆上。</p><p>参考文档：</p><p><a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;iOS 启动，会先在内存空间中开辟一块区域，然后将这块区域内部划分成如下部分。&lt;/p&gt;
&lt;img src=&quot;/2019/03/23/iOS内
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
      <category term="内存" scheme="http://yoursite.com/categories/iOS/%E5%86%85%E5%AD%98/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
