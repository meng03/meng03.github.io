<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>软件开发实践学习记录</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-30T09:36:06.046Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>冰川</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MMKV</title>
    <link href="http://yoursite.com/2019/07/26/MMKV/"/>
    <id>http://yoursite.com/2019/07/26/MMKV/</id>
    <published>2019-07-26T02:36:25.000Z</published>
    <updated>2019-07-30T09:36:06.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MMKV是基于mmap的键值存储库。提供了类似NSUserDefaults的功能。</p><h2 id="MMKV的基础-MMAP"><a href="#MMKV的基础-MMAP" class="headerlink" title="MMKV的基础 - MMAP"></a>MMKV的基础 - MMAP</h2><p>mmap主要有2种用法，一个是建立匿名映射，可以起到父子进程之间共享内存的作用。另一个是磁盘文件映射进程的虚拟地址空间。MMKV就是用的磁盘文件映射。</p><p>mmap的主要的好处在于，减少一次内存拷贝。在我们平时的read/write系统调用中，文件内容的拷贝要多经历内核缓冲区这个阶段，所以比mmap多了一次内存拷贝，mmap只有用户空间的内存拷贝(这个阶段read/write也有）。正是因为减少了从Linux的页缓存到用户空间的缓冲区的这一次拷贝，所以mmap大大提高了性能，mmap也被称为zero-copy技术。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li>创建文件或者指定文件</li><li>打开文件</li><li>调整文件大小（非必须步骤）</li><li>mmap内存映射</li><li>拷贝内容到映射区</li><li>扩容 （看需要）</li><li>munmap结束映射</li><li>关闭文件</li></ul><h3 id="创建或者打开文件"><a href="#创建或者打开文件" class="headerlink" title="创建或者打开文件"></a>创建或者打开文件</h3><p>没什么可说的，指定路径，创建文件。</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>使用open函数，返回文件句柄</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_fd = open([url UTF8String], O_RDWR,S_IRWXU);</span><br><span class="line">if (_fd &lt; 0) &#123;</span><br><span class="line">    NSLog(@&quot;fail to open file:%@&quot;,url);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t fileSize = 0;</span><br><span class="line">struct stat st = &#123;&#125;;</span><br><span class="line">if (fstat(_fd, &amp;st) != -1) &#123;</span><br><span class="line">     fileSize = (size_t) st.st_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调整文件大小"><a href="#调整文件大小" class="headerlink" title="调整文件大小"></a>调整文件大小</h3><p>如果设置的比文件小，则会截取文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//代表将文件中多大的部分对应到内存。以字节为单位，不足一内存页按一内存页处理</span><br><span class="line">//向上取整，找到pagesize的整倍数</span><br><span class="line">size_t pageSize = getpagesize();</span><br><span class="line">if (fileSize == 0 || fileSize/pageSize != 0) &#123;</span><br><span class="line">    _mmapSize = (fileSize/pageSize + 1) * pageSize;</span><br><span class="line">    if (ftruncate(_fd, _mmapSize) != 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    _mmapSize = pageSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件内存映射"><a href="#文件内存映射" class="headerlink" title="文件内存映射"></a>文件内存映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void *start = NULL; //由系统选定地址</span><br><span class="line">off_t offset = 0;//offset为文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。可以简单理解为被映射对象内容的起点。</span><br><span class="line">_ptr = (char *) mmap(start, _mmapSize, PROT_READ | PROT_WRITE, MAP_SHARED, _fd, offset);</span><br><span class="line">if (_ptr == MAP_FAILED) &#123;</span><br><span class="line">    NSLog(@&quot;mmap失败,%s&quot;,strerror(errno));</span><br><span class="line">    //EBADF 参数fd 不是有效的文件描述词</span><br><span class="line">    //EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用MAP_SHARED则要有PROT_WRITE以及该文件要能写入。</span><br><span class="line">    //EINVAL 参数start、length 或offset有一个不合法。</span><br><span class="line">    //EAGAIN 文件被锁住，或是有太多内存被锁住。</span><br><span class="line">    //ENOMEM 内存不足。</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数原型为<code>void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offsize);</code><br>参数介绍：</p><ul><li><p><strong>start</strong> 传入一个期望的映射起始地址。同常传入null，由系统寻找合适的内存区域，并将地址返回。</p></li><li><p><strong>length</strong> 传入映射的长度</p></li><li><p><strong>port</strong> 映射区域的操作属性，有如下四种类型，这里我们使用读写属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#definePROT_NONE0x00/* [MC2] no permissions */</span><br><span class="line">#definePROT_READ0x01/* [MC2] pages can be read */</span><br><span class="line">#definePROT_WRITE0x02/* [MC2] pages can be written */</span><br><span class="line">#definePROT_EXEC0x04/* [MC2] pages can be executed */</span><br></pre></td></tr></table></figure></li><li><p><strong>flag</strong> 会影响映射区域的各种特性，可以看下定义，类型比较多</p></li><li><p><strong>fd</strong> 打开的文件句柄</p></li><li><p><strong>offset</strong> 为文件映射的偏移量，通常设置为0，代表从文件最前方开始对应</p></li></ul><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>需要三个步骤，使用ftruncate扩容文件，munmap结束映射，使用新的大小，重新映射。比如如下方法，是一个添加数据的方法，内存不够会扩容后继续添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)appendData: (NSData *)data &#123;</span><br><span class="line">    if ((_offset + data.length) &gt; _mmapSize) &#123;</span><br><span class="line">        off_t newSize = _mmapSize + getpagesize();</span><br><span class="line">        if (ftruncate(_fd, newSize) != 0) &#123;</span><br><span class="line">            NSLog(@&quot;fail to truncate [%zu] to size %lld, %s&quot;, _mmapSize, newSize, strerror(errno));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (munmap(_ptr, _mmapSize) != 0) &#123;</span><br><span class="line">            NSLog(@&quot;fail to munmap, %s&quot;, strerror(errno));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        _mmapSize = newSize;</span><br><span class="line">        _ptr = (char *) mmap(NULL, _mmapSize, PROT_READ | PROT_WRITE, MAP_SHARED, _fd, 0);</span><br><span class="line">        if (_ptr == MAP_FAILED) &#123;</span><br><span class="line">            NSLog(@&quot;mmap失败,%s&quot;,strerror(errno));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(_ptr + _offset, data.bytes, data.length);</span><br><span class="line">    _offset = _offset + data.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MMKV-数据处理概要"><a href="#MMKV-数据处理概要" class="headerlink" title="MMKV 数据处理概要"></a>MMKV 数据处理概要</h2><p>一个MMKV实例会产生两个文件，内容文件，CRC校验文件。校验文件就是存储了内容文件中内容部分的CRC校验值。内容文件的前四个字节存储内容长度，后面这个长度的数据是实际内容。因为文件扩容是以页的整数倍。所以可能还会有一些空白内容在最后。</p><p>MMKV启动会读取文件，根据文件长度，把实际数据读取出来转成字典。其中还会进行CRC校验。</p><p>后续的操作，不管是读还是写，都是对这个字典进行操作。写操作之后会设置<code>m_hasFullWriteBack = NO;</code>。表示有内容没有写回。之后会在合适的时机调用<code>[self fullWriteBack]</code>进行数据写入。</p><h2 id="MMKV-set的实现"><a href="#MMKV-set的实现" class="headerlink" title="MMKV set的实现"></a>MMKV set的实现</h2><h3 id="set的基本逻辑"><a href="#set的基本逻辑" class="headerlink" title="set的基本逻辑"></a>set的基本逻辑</h3><p>字典中存的值都是NSData类型，所以数据在存入字典前，需要进行一下转化，如下是基本逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)setFloat:(float)value forKey:(NSString *)key &#123;</span><br><span class="line">if (key.length &lt;= 0) &#123;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">    //获取Float类型的长度，4个字节</span><br><span class="line">size_t size = pbFloatSize(value);</span><br><span class="line">    //创建一个data，用来保存这个float</span><br><span class="line">NSMutableData *data = [NSMutableData dataWithLength:size];</span><br><span class="line">    //构建MiniCodedOutputData，来做float转data</span><br><span class="line">MiniCodedOutputData output(data);</span><br><span class="line">    //将float写入data</span><br><span class="line">output.writeFloat(value);</span><br><span class="line">    //将数据写入词典</span><br><span class="line">return [self setRawData:data forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MMKV 实现了<code>MiniCodedOutputData</code>类，来处理字节信息。下面的类型到Data的转换就是通过此类完成。首先<code>writeRawByte</code>方法，提供安字节写入的功能，直接填充一个字节，然后位置后移一位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MiniCodedOutputData::writeRawByte(<span class="keyword">uint8_t</span> value) &#123;</span><br><span class="line"><span class="keyword">if</span> (m_position == m_size) &#123;</span><br><span class="line">NSString *reason = [NSString stringWithFormat:@<span class="string">"position: %d, bufferLength: %u"</span>, m_position, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) m_size];</span><br><span class="line">@<span class="keyword">throw</span> [NSException exceptionWithName:@<span class="string">"OutOfSpace"</span> reason:reason userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line">m_ptr[m_position++] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的数据转成NSData的逻辑不一样，整体逻辑是分割成字节，然后使用<code>writeRawByte</code>写入</p><h4 id="Bool类型"><a href="#Bool类型" class="headerlink" title="Bool类型"></a>Bool类型</h4><p>Bool类型只占一个字节，直接写入即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MiniCodedOutputData::writeBool(BOOL value) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawByte(value ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Float类型"><a href="#Float类型" class="headerlink" title="Float类型"></a>Float类型</h4><p>32位float类型按照小顶端顺序分成4个字节存入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void MiniCodedOutputData::writeRawLittleEndian32(int32_t value) &#123;</span><br><span class="line">this-&gt;writeRawByte((value) &amp;0xff);</span><br><span class="line">this-&gt;writeRawByte((value &gt;&gt; 8) &amp; 0xff);</span><br><span class="line">this-&gt;writeRawByte((value &gt;&gt; 16) &amp; 0xff);</span><br><span class="line">this-&gt;writeRawByte((value &gt;&gt; 24) &amp; 0xff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>64位的类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void MiniCodedOutputData::writeRawLittleEndian64(int64_t value) &#123;</span><br><span class="line">this-&gt;writeRawByte((int32_t)(value) &amp;0xff);</span><br><span class="line">this-&gt;writeRawByte((int32_t)(value &gt;&gt; 8) &amp; 0xff);</span><br><span class="line">this-&gt;writeRawByte((int32_t)(value &gt;&gt; 16) &amp; 0xff);</span><br><span class="line">this-&gt;writeRawByte((int32_t)(value &gt;&gt; 24) &amp; 0xff);</span><br><span class="line">this-&gt;writeRawByte((int32_t)(value &gt;&gt; 32) &amp; 0xff);</span><br><span class="line">this-&gt;writeRawByte((int32_t)(value &gt;&gt; 40) &amp; 0xff);</span><br><span class="line">this-&gt;writeRawByte((int32_t)(value &gt;&gt; 48) &amp; 0xff);</span><br><span class="line">this-&gt;writeRawByte((int32_t)(value &gt;&gt; 56) &amp; 0xff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Int类型"><a href="#Int类型" class="headerlink" title="Int类型"></a>Int类型</h4><p>Int类型的存储逻辑稍有不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MiniCodedOutputData::writeInt64(<span class="keyword">int64_t</span> value) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawVarint64(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MiniCodedOutputData::writeRawVarint64(<span class="keyword">int64_t</span> value) &#123;</span><br><span class="line"><span class="keyword">while</span> (YES) &#123;</span><br><span class="line">    <span class="comment">//对0x7FL的取反，在&amp; 结果为0，意味着只有后七位有值</span></span><br><span class="line"><span class="keyword">if</span> ((value &amp; ~<span class="number">0x7F</span>L) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawByte((<span class="keyword">int32_t</span>) value);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//(value &amp; 0x7f) | 0x80</span></span><br><span class="line">      <span class="comment">// 先 &amp; 0111 1111 ：取后七位，在 | 10000000 ： 首位填1</span></span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawByte(((<span class="keyword">int32_t</span>) value &amp; <span class="number">0x7f</span>) | <span class="number">0x80</span>);</span><br><span class="line">      <span class="comment">//写入后，右移7位继续</span></span><br><span class="line">value = logicalRightShift64(value, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>64位Int类型是每次存7位，首位填1的方式存储。共需要10个字节。7*9 = 63，最后一个字节只存一位。这里每次只处理7位的原因，会在后续进行说明。</p><p>32位的Int类型类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MiniCodedOutputData::writeRawVarint32(<span class="keyword">int32_t</span> value) &#123;</span><br><span class="line"><span class="keyword">while</span> (YES) &#123;</span><br><span class="line"><span class="keyword">if</span> ((value &amp; ~<span class="number">0x7f</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawByte(value);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawByte((value &amp; <span class="number">0x7f</span>) | <span class="number">0x80</span>);</span><br><span class="line">value = logicalRightShift32(value, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSData类型"><a href="#NSData类型" class="headerlink" title="NSData类型"></a>NSData类型</h4><p>data类型的写入，需要记录data的长度，以及值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MiniCodedOutputData::writeData(NSData *value) &#123;</span><br><span class="line">  <span class="comment">//写入data的长度</span></span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawVarint32((<span class="keyword">int32_t</span>) value.length);</span><br><span class="line">  <span class="comment">//写入data本身</span></span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawData(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长度的写入已经介绍过了，下面看下Data类型的写入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MiniCodedOutputData::writeRawData(NSData *data) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawData(data, <span class="number">0</span>, (<span class="keyword">int32_t</span>) data.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MiniCodedOutputData::writeRawData(NSData *value, <span class="keyword">int32_t</span> offset, <span class="keyword">int32_t</span> length) &#123;</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_size - m_position &gt;= length) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(m_ptr + m_position, ((<span class="keyword">uint8_t</span> *) value.bytes) + offset, length);</span><br><span class="line">m_position += length;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">[NSException exceptionWithName:@<span class="string">"Space"</span> reason:@<span class="string">"too much data than calc"</span> userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data类型比较容易处理，直接内存拷贝即可。</p><h4 id="NSString类型"><a href="#NSString类型" class="headerlink" title="NSString类型"></a>NSString类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MiniCodedOutputData::writeString(NSString *value) &#123;</span><br><span class="line">NSUInteger numberOfBytes = [value lengthOfBytesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"><span class="keyword">this</span>-&gt;writeRawVarint32((<span class="keyword">int32_t</span>) numberOfBytes);</span><br><span class="line">[value getBytes:m_ptr + m_position</span><br><span class="line">         maxLength:numberOfBytes</span><br><span class="line">        usedLength:<span class="number">0</span></span><br><span class="line">          encoding:NSUTF8StringEncoding</span><br><span class="line">           options:<span class="number">0</span></span><br><span class="line">             range:NSMakeRange(<span class="number">0</span>, value.length)</span><br><span class="line">    remainingRange:<span class="literal">nullptr</span>];</span><br><span class="line">m_position += numberOfBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NSString 类型和Data类似，先写入长度，在转成Data存入。NSString有个方便的方法，直接将数据放到指定的内存位置。这里正好合用。</p><h3 id="取数据的基本逻辑"><a href="#取数据的基本逻辑" class="headerlink" title="取数据的基本逻辑"></a>取数据的基本逻辑</h3><p>取数据的逻辑是对set的反向操作，先从字典中取出数据，然后转成具体类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int64_t</span>)getInt64ForKey:(NSString *)key &#123;</span><br><span class="line"><span class="keyword">return</span> [self getInt64ForKey:key defaultValue:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int64_t</span>)getInt64ForKey:(NSString *)key defaultValue:(<span class="keyword">int64_t</span>)defaultValue &#123;</span><br><span class="line"><span class="keyword">if</span> (key.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> defaultValue;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//从通过key从字典中取出数据，类型是NSData</span></span><br><span class="line">NSData *data = [self getRawDataForKey:key];</span><br><span class="line"><span class="keyword">if</span> (data.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">@<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将Data类型转成Int64</span></span><br><span class="line"><span class="function">MiniCodedInputData <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="keyword">return</span> input.readInt64();</span><br><span class="line">&#125; @<span class="keyword">catch</span> (NSException *exception) &#123;</span><br><span class="line">MMKVError(@<span class="string">"%@"</span>, exception);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MMKV实现了MiniCodedInputData来将NSData转成需要的类型。这个类的操作是MiniCodedOutputData的反向操作。其他都比较类似，这里看一下<code>readRawVarint64</code>方法，解释下之前的留下的小问题，为什么要每7位存一个字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> MiniCodedInputData::readRawVarint64() &#123;</span><br><span class="line"><span class="keyword">int32_t</span> shift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int64_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (shift &lt; <span class="number">64</span>) &#123;</span><br><span class="line"><span class="keyword">int8_t</span> b = <span class="keyword">this</span>-&gt;readRawByte();</span><br><span class="line">result |= (<span class="keyword">int64_t</span>)(b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">shift += <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">throw</span> [NSException exceptionWithName:@<span class="string">"InvalidProtocolBuffer"</span> reason:@<span class="string">"malformedVarint"</span> userInfo:nil];</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取的字节是存到一个8位Int中 <code>int8_t b = this-&gt;readRawByte();</code>。前面的逻辑中每次存入七位，首位填1，因为首位是填充的，没有意义，这里通过 &amp; 0x7f直接移除。如果是8位存储，首位的1会使这个数据变成负数，这里的处理就会变得比较麻烦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;MMKV是基于mmap的键值存储库。提供了类似NSUserDefaults的功能。&lt;/p&gt;
&lt;h2 id=&quot;MMKV的基础-MMAP&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="mmap" scheme="http://yoursite.com/tags/mmap/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>kingfisher源码阅读</title>
    <link href="http://yoursite.com/2019/07/01/kingfisher%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/07/01/kingfisher源码阅读/</id>
    <published>2019-07-01T08:05:22.000Z</published>
    <updated>2019-07-17T08:56:02.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><h3 id="通用模块"><a href="#通用模块" class="headerlink" title="通用模块"></a>通用模块</h3><h4 id="ImageSource"><a href="#ImageSource" class="headerlink" title="ImageSource"></a>ImageSource</h4><p>Kingfisher中对图片资源的表示有两种，定义在Source枚举中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> network(<span class="type">Resource</span>)</span><br><span class="line">  <span class="keyword">case</span> provider(<span class="type">ImageDataProvider</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>network</code>类型的需要提供一个url和cacheKey，然后kingfisher会自行下载。provider类型的，是自己提供image数据。下面看下Resource</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// The key used in cache.</span></span><br><span class="line">    <span class="keyword">var</span> cacheKey: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// The target image URL.</span></span><br><span class="line">    <span class="keyword">var</span> downloadURL: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Resource的协议需要两个属性，下载地址和缓存key。正常情况下我们无需实现这个Resource，因为Kingfisher中的URL通过extension实现了这个协议，我们平常直接用URL就可以了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URL</span>: <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cacheKey: <span class="type">String</span> &#123; <span class="keyword">return</span> absoluteString &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> downloadURL: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果你想定制key的格式，可以使用Resource的另一个实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">ImageResource</span>: <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(downloadURL: <span class="type">URL</span>, cacheKey: <span class="type">String?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadURL = downloadURL</span><br><span class="line">        <span class="keyword">self</span>.cacheKey = cacheKey ?? downloadURL.absoluteString</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> cacheKey: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> downloadURL: <span class="type">URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImageDataProvider 提供了三个实现，分别是<code>LocalFileImageDataProvider</code>，<code>Base64ImageDataProvider</code>，<code>RawImageDataProvider</code>。三种方式提供image的data，不过这个没什么使用场景，源码中，也只在测试的地方有用到。</p><h4 id="KingfisherError"><a href="#KingfisherError" class="headerlink" title="KingfisherError"></a>KingfisherError</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">KingfisherError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line"><span class="comment">/// Represents the error reason during networking request phase.</span></span><br><span class="line">    <span class="keyword">case</span> requestError(reason: <span class="type">RequestErrorReason</span>)</span><br><span class="line">    <span class="comment">/// Represents the error reason during networking response phase.</span></span><br><span class="line">    <span class="keyword">case</span> responseError(reason: <span class="type">ResponseErrorReason</span>)</span><br><span class="line">    <span class="comment">/// Represents the error reason during Kingfisher caching system.</span></span><br><span class="line">    <span class="keyword">case</span> cacheError(reason: <span class="type">CacheErrorReason</span>)</span><br><span class="line">    <span class="comment">/// Represents the error reason during image processing phase.</span></span><br><span class="line">    <span class="keyword">case</span> processorError(reason: <span class="type">ProcessorErrorReason</span>)</span><br><span class="line">    <span class="comment">/// Represents the error reason during image setting in a view related class.</span></span><br><span class="line">    <span class="keyword">case</span> imageSettingError(reason: <span class="type">ImageSettingErrorReason</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kingfisher 将 error 按照过程划分，分别是请求，返回，缓存，处理，设置，每个过程一种 error 类型。</p><p>###下载</p><p>当缓存没有命中的时候，就会启动一个下载。下载主要用到两个类，<code>ImageDownloader</code>启动下载，并处理回调，SessionDelegate处理URLSessionDataTask的下载代理，并提供任务管理功能。图片下载过程中，会通过<code>ImageDownloaderDelegate</code>通知外部。</p><p>此外可以通过ImageDownloadRequestModifier拦截修改图片的url。</p><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><p>Kingfisher提供丰富的图片处理功能。这些功能通过<code>ImageProcessor</code>来提供，如果有需要其他的处理，可以自行实现这个协议来提供，比如webp格式的图片处理。</p><p>Kingfisher在demo中列出了目前已经提供了的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">DefaultImageProcessor</span>.<span class="keyword">default</span>, <span class="string">"Default"</span>),</span><br><span class="line">(<span class="type">RoundCornerImageProcessor</span>(cornerRadius: <span class="number">20</span>), <span class="string">"Round Corner"</span>),</span><br><span class="line">(<span class="type">RoundCornerImageProcessor</span>(cornerRadius: <span class="number">20</span>, roundingCorners: [.topLeft, .bottomRight]), <span class="string">"Round Corner Partial"</span>),</span><br><span class="line">(<span class="type">BlendImageProcessor</span>(blendMode: .lighten, alpha: <span class="number">1.0</span>, backgroundColor: .red), <span class="string">"Blend"</span>),</span><br><span class="line">(<span class="type">BlurImageProcessor</span>(blurRadius: <span class="number">5</span>), <span class="string">"Blur"</span>),</span><br><span class="line">(<span class="type">OverlayImageProcessor</span>(overlay: .red, fraction: <span class="number">0.5</span>), <span class="string">"Overlay"</span>),</span><br><span class="line">(<span class="type">TintImageProcessor</span>(tint: <span class="type">UIColor</span>.red.withAlphaComponent(<span class="number">0.5</span>)), <span class="string">"Tint"</span>),</span><br><span class="line">(<span class="type">ColorControlsProcessor</span>(brightness: <span class="number">0.0</span>, contrast: <span class="number">1.1</span>, saturation: <span class="number">1.1</span>, inputEV: <span class="number">1.0</span>), <span class="string">"Vibrancy"</span>),</span><br><span class="line">(<span class="type">BlackWhiteProcessor</span>(), <span class="string">"B&amp;W"</span>),</span><br><span class="line">(<span class="type">CroppingImageProcessor</span>(size: <span class="type">CGSize</span>(width: <span class="number">100</span>, height: <span class="number">100</span>)), <span class="string">"Cropping"</span>),</span><br><span class="line">(<span class="type">DownsamplingImageProcessor</span>(size: <span class="type">CGSize</span>(width: <span class="number">25</span>, height: <span class="number">25</span>)), <span class="string">"Downsampling"</span>),</span><br><span class="line">(<span class="type">BlurImageProcessor</span>(blurRadius: <span class="number">5</span>) &gt;&gt; <span class="type">RoundCornerImageProcessor</span>(cornerRadius: <span class="number">20</span>), <span class="string">"Blur + Round Corner"</span>)</span><br></pre></td></tr></table></figure><p>这些功能主要通过 <code>ImageDrawing</code>中的方法来实现。</p><p>####圆角</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span><span class="params">(withRoundRadius radius: CGFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fit size: CGSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                  roundingCorners corners: RectCorner = .all,</span></span></span><br><span class="line"><span class="function"><span class="params">                  backgroundColor: Color? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">Image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> rect = <span class="type">CGRect</span>(origin: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), size: size)</span><br><span class="line">    <span class="keyword">return</span> draw(to: size) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">assertionFailure</span>(<span class="string">"[Kingfisher] Failed to create CG context for image."</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> backgroundColor = backgroundColor &#123;</span><br><span class="line">            <span class="keyword">let</span> rectPath = <span class="type">UIBezierPath</span>(rect: rect)</span><br><span class="line">            backgroundColor.setFill()</span><br><span class="line">            rectPath.fill()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>(</span><br><span class="line">            roundedRect: rect,</span><br><span class="line">            byRoundingCorners: corners.uiRectCorner,</span><br><span class="line">            cornerRadii: <span class="type">CGSize</span>(width: radius, height: radius)</span><br><span class="line">        )</span><br><span class="line">        context.addPath(path.cgPath)</span><br><span class="line">        context.clip()</span><br><span class="line">        base.draw(<span class="keyword">in</span>: rect)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>draw</code>方法负责开启上下文和关闭上下文，block中是绘制的主要代码。</p><h4 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">blurred</span><span class="params">(withRadius radius: CGFloat)</span></span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="comment">// http://www.w3.org/TR/SVG/filters.html#feGaussianBlurElement</span></span><br><span class="line">    <span class="comment">// let d = floor(s * 3*sqrt(2*pi)/4 + 0.5)</span></span><br><span class="line">    <span class="comment">// if d is odd, use three box-blurs of size 'd', centered on the output pixel.</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="type">Float</span>(<span class="built_in">max</span>(radius, <span class="number">2.0</span>))</span><br><span class="line">    <span class="comment">// We will do blur on a resized image (*0.5), so the blur radius could be half as well.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fix the slow compiling time for Swift 3.</span></span><br><span class="line">    <span class="comment">// See https://github.com/onevcat/Kingfisher/issues/611</span></span><br><span class="line">    <span class="keyword">let</span> pi2 = <span class="number">2</span> * <span class="type">Float</span>.pi</span><br><span class="line">    <span class="keyword">let</span> sqrtPi2 = sqrt(pi2)</span><br><span class="line">    <span class="keyword">var</span> targetRadius = floor(s * <span class="number">3.0</span> * sqrtPi2 / <span class="number">4.0</span> + <span class="number">0.5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> targetRadius.isEven &#123; targetRadius += <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine necessary iteration count by blur radius.</span></span><br><span class="line">    <span class="keyword">let</span> iterations: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">if</span> radius &lt; <span class="number">0.5</span> &#123;</span><br><span class="line">        iterations = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> radius &lt; <span class="number">1.5</span> &#123;</span><br><span class="line">        iterations = <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iterations = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> w = <span class="type">Int</span>(size.width)</span><br><span class="line">    <span class="keyword">let</span> h = <span class="type">Int</span>(size.height)</span><br><span class="line">    <span class="keyword">let</span> rowBytes = <span class="type">Int</span>(<span class="type">CGFloat</span>(cgImage.bytesPerRow))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createEffectBuffer</span><span class="params">(<span class="number">_</span> context: CGContext)</span></span> -&gt; vImage_Buffer &#123;</span><br><span class="line">        <span class="keyword">let</span> data = context.data</span><br><span class="line">        <span class="keyword">let</span> width = vImagePixelCount(context.width)</span><br><span class="line">        <span class="keyword">let</span> height = vImagePixelCount(context.height)</span><br><span class="line">        <span class="keyword">let</span> rowBytes = context.bytesPerRow</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vImage_Buffer(data: data, height: height, width: width, rowBytes: rowBytes)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> context = beginContext(size: size, scale: scale, inverting: <span class="literal">true</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">"[Kingfisher] Failed to create CG context for blurring image."</span>)</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    context.draw(cgImage, <span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: w, height: h))</span><br><span class="line">    endContext()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> inBuffer = createEffectBuffer(context)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> outContext = beginContext(size: size, scale: scale, inverting: <span class="literal">true</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">"[Kingfisher] Failed to create CG context for blurring image."</span>)</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> &#123; endContext() &#125;</span><br><span class="line">    <span class="keyword">var</span> outBuffer = createEffectBuffer(outContext)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span> ..&lt; iterations &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = vImage_Flags(kvImageEdgeExtend)</span><br><span class="line">        vImageBoxConvolve_ARGB8888(</span><br><span class="line">            &amp;inBuffer, &amp;outBuffer, <span class="literal">nil</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="type">UInt32</span>(targetRadius), <span class="type">UInt32</span>(targetRadius), <span class="literal">nil</span>, flag)</span><br><span class="line">        <span class="comment">// Next inBuffer should be the outButter of current iteration</span></span><br><span class="line">        (inBuffer, outBuffer) = (outBuffer, inBuffer)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result = outContext.makeImage().flatMap &#123;</span><br><span class="line">        <span class="type">Image</span>(cgImage: $<span class="number">0</span>, scale: base.scale, orientation: base.imageOrientation)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> blurredImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模糊是通过Accelerate.framework中的vImage实现，使用vImage来做比较自由，但是比较麻烦，需要了解算法细节。</p><p>其他的诸如Size，blend都比较简单。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><p>Kingfisher有两个关于缓存策略的枚举，<code>StorageExpiration</code>用来表示文件创建成功后的缓存策略。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StorageExpiration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The item never expires.</span></span><br><span class="line">    <span class="keyword">case</span> never</span><br><span class="line">    <span class="comment">/// The item expires after a time duration of given seconds from now.</span></span><br><span class="line">    <span class="keyword">case</span> seconds(<span class="type">TimeInterval</span>)</span><br><span class="line">    <span class="comment">/// The item expires after a time duration of given days from now.</span></span><br><span class="line">    <span class="keyword">case</span> days(<span class="type">Int</span>)</span><br><span class="line">    <span class="comment">/// The item expires after a given date.</span></span><br><span class="line">    <span class="keyword">case</span> date(<span class="type">Date</span>)</span><br><span class="line">    <span class="comment">/// Indicates the item is already expired. Use this to skip cache.</span></span><br><span class="line">    <span class="keyword">case</span> expired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExpirationExtending</code>用来表示再次访问后，如何更新该文件的缓存策略。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExpirationExtending</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The item expires after the original time, without extending after access.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="comment">/// The item expiration extends by the original cache time after each access.</span></span><br><span class="line">    <span class="keyword">case</span> cacheTime</span><br><span class="line">    <span class="comment">/// The item expiration extends by the provided time after each access.</span></span><br><span class="line">    <span class="keyword">case</span> expirationTime(<span class="number">_</span> expiration: <span class="type">StorageExpiration</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h4><p>kingfisher内存缓存<code>MemoryStorage</code>定义了一个命名空间，里面有三个对象，<code>Config</code>，<code>StorageObject</code>和实际用来做处理的<code>Backend</code>。</p><p><code>StorageObject</code>包括数据value，过期策略，和缓存的key值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StorageObject</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value: <span class="type">T</span></span><br><span class="line">  <span class="keyword">let</span> expiration: <span class="type">StorageExpiration</span></span><br><span class="line">  <span class="keyword">let</span> key: <span class="type">String</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存配置对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MemoryStorage</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Represents the config used in a `MemoryStorage`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="comment">//缓存容量上限</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">var</span> totalCostLimit: <span class="type">Int</span></span><br><span class="line">        <span class="comment">//缓存数量上限</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">var</span> countLimit: <span class="type">Int</span> = .<span class="built_in">max</span></span><br><span class="line">        <span class="comment">//过期策略</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">var</span> expiration: <span class="type">StorageExpiration</span> = .seconds(<span class="number">300</span>)</span><br><span class="line">        <span class="comment">//清理周期</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">let</span> cleanInterval: <span class="type">TimeInterval</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际做内存缓存处理的类<code>Backend</code>，以<code>NSCache</code>为存储源，将需要存储的数据构造成<code>StorageObject</code>来存储。提供存储，移除，查询三个功能，在查到缓存的时候，会根据延长缓存策略，更新这个对象的缓存策略。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(forKey key: String, extendingExpiration: ExpirationExtending = .cacheTime)</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> object = storage.object(forKey: key <span class="keyword">as</span> <span class="type">NSString</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> object.expired &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    object.extendExpiration(extendingExpiration)</span><br><span class="line">    <span class="keyword">return</span> object.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，会创建一个Timer，每隔一段时间（config中配置的）清理一次NSCache中过期的对象。</p><p>对NSCache的操作，都需要加锁，这里使用的NSLock。</p><h4 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h4><p>磁盘缓存的结构跟内存缓存类似，使用DiskStorage枚举构造一个命名空间。内部定义了三个结构，配置信息<code>Config</code>，代表磁盘文件的<code>FileMeta</code>，以及处理逻辑的<code>Backend</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="comment">//文件大小上限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> sizeLimit: <span class="type">UInt</span></span><br><span class="line">    <span class="comment">//过期策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> expiration: <span class="type">StorageExpiration</span> = .days(<span class="number">7</span>)</span><br><span class="line">    <span class="comment">//文件后缀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> pathExtension: <span class="type">String?</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">//是否使用hash值来表示文件名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> usesHashedFileName = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMeta</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url: <span class="type">URL</span>    </span><br><span class="line">    <span class="keyword">let</span> lastAccessDate: <span class="type">Date?</span></span><br><span class="line">    <span class="keyword">let</span> estimatedExpirationDate: <span class="type">Date?</span></span><br><span class="line">    <span class="keyword">let</span> isDirectory: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">let</span> fileSize: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>磁盘缓存的数据源是磁盘，在查询，删除，存储上，比内存缓存要麻烦一点。</p><p><code>Backend&lt;T: DataTransformable&gt;</code>这里T是内部使用的数据类型。<code>DataTransformable</code>协议定义了T与Data的变换。需要存储时，要从T类型中拿到Data。下面看下store方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    value: T,</span></span></span><br><span class="line"><span class="function"><span class="params">    forKey key: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    expiration: StorageExpiration? = <span class="literal">nil</span>)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//缓存失效策略</span></span><br><span class="line">    <span class="keyword">let</span> expiration = expiration ?? config.expiration</span><br><span class="line">    <span class="keyword">guard</span> !expiration.isExpired <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拿到数据Data</span></span><br><span class="line">    <span class="keyword">let</span> data: <span class="type">Data</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        data = <span class="keyword">try</span> value.toData()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">KingfisherError</span>.cacheError(reason: .cannotConvertToData(object: value, error: error))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key构建存储的url</span></span><br><span class="line">    <span class="keyword">let</span> fileURL = cacheFileURL(forKey: key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造文件属性：创建时间，更新时间（其实是过期时间）</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="type">Date</span>()</span><br><span class="line">    <span class="keyword">let</span> attributes: [<span class="type">FileAttributeKey</span> : <span class="type">Any</span>] = [</span><br><span class="line">        <span class="comment">// The last access date.</span></span><br><span class="line">        .creationDate: now.fileAttributeDate,</span><br><span class="line">        <span class="comment">// The estimated expiration date.</span></span><br><span class="line">        .modificationDate: expiration.estimatedExpirationSinceNow.fileAttributeDate</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//创建文件</span></span><br><span class="line">    config.fileManager.createFile(atPath: fileURL.path, contents: data, attributes: attributes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储文件带的属性，将创建时间和过期时间放进去。方便后续的处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(forKey key: String, referenceDate: Date, actuallyLoad: Bool)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fileManager = config.fileManager</span><br><span class="line">    <span class="keyword">let</span> fileURL = cacheFileURL(forKey: key)</span><br><span class="line">    <span class="keyword">let</span> filePath = fileURL.path</span><br><span class="line">    <span class="keyword">guard</span> fileManager.fileExists(atPath: filePath) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件的meta信息，主要是创建时间，和过期时间</span></span><br><span class="line">    <span class="keyword">let</span> meta: <span class="type">FileMeta</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> resourceKeys: <span class="type">Set</span>&lt;<span class="type">URLResourceKey</span>&gt; = [.contentModificationDateKey, .creationDateKey]</span><br><span class="line">        meta = <span class="keyword">try</span> <span class="type">FileMeta</span>(fileURL: fileURL, resourceKeys: resourceKeys)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">KingfisherError</span>.cacheError(</span><br><span class="line">            reason: .invalidURLResource(error: error, key: key, url: fileURL))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过期则返回nil</span></span><br><span class="line">    <span class="keyword">if</span> meta.expired(referenceDate: referenceDate) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//actuallyLoad为false，表明是为了查询，并不需要加载这个数据</span></span><br><span class="line">    <span class="keyword">if</span> !actuallyLoad &#123; <span class="keyword">return</span> <span class="type">T</span>.empty &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//读取数据，修改过期时间</span></span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: fileURL)</span><br><span class="line">        <span class="keyword">let</span> obj = <span class="keyword">try</span> <span class="type">T</span>.fromData(data)</span><br><span class="line">        metaChangingQueue.async &#123; meta.extendExpiration(with: fileManager) &#125;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">KingfisherError</span>.cacheError(reason: .cannotLoadDataFromDisk(url: fileURL, error: error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>磁盘缓存没有定时清理。App将要进入后台，被杀死和被挂起的时候，会做一次清理。</p><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p><strong>文件写入</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="type">Date</span>()</span><br><span class="line"><span class="keyword">let</span> attributes: [<span class="type">FileAttributeKey</span> : <span class="type">Any</span>] = [</span><br><span class="line">    <span class="comment">// The last access date.</span></span><br><span class="line">    .creationDate: now.fileAttributeDate,</span><br><span class="line">    <span class="comment">// The estimated expiration date.</span></span><br><span class="line">    .modificationDate: expiration.estimatedExpirationSinceNow.fileAttributeDate</span><br><span class="line">]</span><br><span class="line"><span class="comment">//创建文件</span></span><br><span class="line">config.fileManager.createFile(atPath: fileURL.path, contents: data, attributes: attributes)</span><br></pre></td></tr></table></figure><p>缓存的文件写入是通过<code>FileMananger</code>的<code>open func createFile(atPath path: String, contents data: Data?, attributes attr: [FileAttributeKey : Any]? = nil) -&gt; Bool</code>方法写入，在创建时间和修改时间属性中填入当前时间和过期时间。后续可以根据过期时间来清理磁盘。</p><p><strong>文件属性的操作</strong></p><p>读取文件属性可以通过<code>url</code>的<code>resourceValues</code>方法，如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resourceKeys: <span class="type">Set</span>&lt;<span class="type">URLResourceKey</span>&gt; = [.contentModificationDateKey, .creationDateKey]</span><br><span class="line"><span class="keyword">let</span> meta = <span class="keyword">try</span> fileURL.resourceValues(forKeys: resourceKeys)</span><br></pre></td></tr></table></figure><p>文件的属性很多，需要了解更多的，可以查看<code>URLResourceKey</code>这个结构体。库中主要用到了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改时间，实际存储的是过期时间</span></span><br><span class="line">contentModificationDateKey</span><br><span class="line"><span class="comment">//创建时间</span></span><br><span class="line">creationDateKey</span><br><span class="line"><span class="comment">//文件大小</span></span><br><span class="line">fileSizeKey</span><br><span class="line"><span class="comment">//是否是目录</span></span><br><span class="line">isDirectoryKey</span><br></pre></td></tr></table></figure><p>文件属性的修改则是通过<code>FileManager</code>来处理</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> attributes: [<span class="type">FileAttributeKey</span> : <span class="type">Any</span>] = [</span><br><span class="line">                .creationDate: <span class="type">Date</span>().fileAttributeDate,</span><br><span class="line">                .modificationDate: .estimatedExpirationSinceNow.fileAttributeDate</span><br><span class="line">            ]</span><br><span class="line"><span class="keyword">try</span>? fileManager.setAttributes(attributes, ofItemAtPath: url.path)</span><br></pre></td></tr></table></figure><p>文件数据的读入，比较简单</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: fileURL)</span><br></pre></td></tr></table></figure><h4 id="ImageCache"><a href="#ImageCache" class="headerlink" title="ImageCache"></a>ImageCache</h4><p><code>ImageCache</code>包装了磁盘缓存和内存缓存，对外提供简单的查询，存储，清除等功能。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">store(<span class="number">_</span> image: <span class="type">Image</span>,</span><br><span class="line">                original: <span class="type">Data?</span> = <span class="literal">nil</span>,</span><br><span class="line">                forKey key: <span class="type">String</span>,</span><br><span class="line">                options: <span class="type">KingfisherParsedOptionsInfo</span>,</span><br><span class="line">                toDisk: <span class="type">Bool</span> = <span class="literal">true</span>,</span><br><span class="line">                completionHandler: ((<span class="type">CacheStoreResult</span>) -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> identifier = options.processor.identifier</span><br><span class="line">    <span class="keyword">let</span> callbackQueue = options.callbackQueue</span><br><span class="line">    <span class="comment">//创建一个key，用于缓存的键值</span></span><br><span class="line">    <span class="keyword">let</span> computedKey = key.computedKey(with: identifier)</span><br><span class="line">    <span class="comment">//使用内存缓存存储</span></span><br><span class="line">    memoryStorage.storeNoThrow(value: image, forKey: computedKey, expiration: options.memoryCacheExpiration)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> toDisk <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不需要存磁盘，这里就算存储成功里，构建callback</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> completionHandler = completionHandler &#123;</span><br><span class="line">            <span class="keyword">let</span> result = <span class="type">CacheStoreResult</span>(memoryCacheResult: .success(()), diskCacheResult: .success(()))</span><br><span class="line">            callbackQueue.execute &#123; completionHandler(result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//io专用的队列，异步将data存入磁盘</span></span><br><span class="line">    ioQueue.async &#123;</span><br><span class="line">        <span class="keyword">let</span> serializer = options.cacheSerializer</span><br><span class="line">        <span class="comment">//将数据序列化</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> data = serializer.data(with: image, original: original) &#123;</span><br><span class="line">            <span class="comment">//调用同步存磁盘的方法，方法的实现是调用磁盘缓存的store方法</span></span><br><span class="line">            <span class="keyword">self</span>.syncStoreToDisk(</span><br><span class="line">                data,</span><br><span class="line">                forKey: key,</span><br><span class="line">                processorIdentifier: identifier,</span><br><span class="line">                callbackQueue: callbackQueue,</span><br><span class="line">                expiration: options.diskCacheExpiration,</span><br><span class="line">                completionHandler: completionHandler)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> completionHandler = completionHandler <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> diskError = <span class="type">KingfisherError</span>.cacheError(</span><br><span class="line">                reason: .cannotSerializeImage(image: image, original: original, serializer: serializer))</span><br><span class="line">            <span class="keyword">let</span> result = <span class="type">CacheStoreResult</span>(</span><br><span class="line">                memoryCacheResult: .success(()),</span><br><span class="line">                diskCacheResult: .failure(diskError))</span><br><span class="line">            callbackQueue.execute &#123; completionHandler(result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h2><p>Kingfisher最常用的方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://example.com/image.png"</span>)</span><br><span class="line">imageView.kf.setImage(with: url)</span><br></pre></td></tr></table></figure><p>入口即<code>setImage</code>，从这个方法进去看看</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">setImage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    with source: Source?,</span></span></span><br><span class="line"><span class="function"><span class="params">    placeholder: Placeholder? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    options: KingfisherOptionsInfo? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    progressBlock: DownloadProgressBlock? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completionHandler: <span class="params">(<span class="params">(Result&lt;RetrieveImageResult, KingfisherError&gt;)</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>) -&gt; <span class="type">DownloadTask?</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> mutatingSelf = <span class="keyword">self</span></span><br><span class="line">    <span class="comment">//没有source直接返回</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> source = source <span class="keyword">else</span> &#123;</span><br><span class="line">        mutatingSelf.placeholder = placeholder</span><br><span class="line">        mutatingSelf.taskIdentifier = <span class="literal">nil</span></span><br><span class="line">        completionHandler?(.failure(<span class="type">KingfisherError</span>.imageSettingError(reason: .emptySource)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理options</span></span><br><span class="line">    <span class="keyword">var</span> options = <span class="type">KingfisherParsedOptionsInfo</span>(<span class="type">KingfisherManager</span>.shared.defaultOptions + (options ?? .empty))</span><br><span class="line">    <span class="keyword">let</span> noImageOrPlaceholderSet = base.image == <span class="literal">nil</span> &amp;&amp; <span class="keyword">self</span>.placeholder == <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> !options.keepCurrentImageWhileLoading || noImageOrPlaceholderSet &#123;</span><br><span class="line">        <span class="comment">// Always set placeholder while there is no image/placeholder yet.</span></span><br><span class="line">        mutatingSelf.placeholder = placeholder</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有动画，启动动画</span></span><br><span class="line">    <span class="keyword">let</span> maybeIndicator = indicator</span><br><span class="line">    maybeIndicator?.startAnimatingView()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取自增值作为任务的Identifier</span></span><br><span class="line">    <span class="keyword">let</span> issuedIdentifier = <span class="type">Source</span>.<span class="type">Identifier</span>.next()</span><br><span class="line">    mutatingSelf.taskIdentifier = issuedIdentifier</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> base.shouldPreloadAllAnimation() &#123;</span><br><span class="line">        options.preloadAllAnimationData = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进度block</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> block = progressBlock &#123;</span><br><span class="line">        options.onDataReceived = (options.onDataReceived ?? []) + [<span class="type">ImageLoadingProgressSideEffect</span>(block)]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> provider = <span class="type">ImageProgressiveProvider</span>(options, refresh: &#123; image <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.base.image = image</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        options.onDataReceived = (options.onDataReceived ?? []) + [provider]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    options.onDataReceived?.forEach &#123;</span><br><span class="line">        $<span class="number">0</span>.onShouldApply = &#123; issuedIdentifier == <span class="keyword">self</span>.taskIdentifier &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过KingfisherManager来获取图片</span></span><br><span class="line">    <span class="keyword">let</span> task = <span class="type">KingfisherManager</span>.shared.retrieveImage(</span><br><span class="line">        with: source,</span><br><span class="line">        options: options,</span><br><span class="line">        completionHandler: &#123; result <span class="keyword">in</span></span><br><span class="line">            <span class="type">CallbackQueue</span>.mainCurrentOrAsync.execute &#123;</span><br><span class="line">                maybeIndicator?.stopAnimatingView()</span><br><span class="line">                <span class="comment">//如果拿到图片后，任务已经不是当前任务了，就不处理</span></span><br><span class="line">                <span class="keyword">guard</span> issuedIdentifier == <span class="keyword">self</span>.taskIdentifier <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> reason: <span class="type">KingfisherError</span>.<span class="type">ImageSettingErrorReason</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> value = <span class="keyword">try</span> result.<span class="keyword">get</span>()</span><br><span class="line">                        reason = .notCurrentSourceTask(result: value, error: <span class="literal">nil</span>, source: source)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                        reason = .notCurrentSourceTask(result: <span class="literal">nil</span>, error: error, source: source)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> error = <span class="type">KingfisherError</span>.imageSettingError(reason: reason)</span><br><span class="line">                    completionHandler?(.failure(error))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                mutatingSelf.imageTask = <span class="literal">nil</span></span><br><span class="line">                mutatingSelf.taskIdentifier = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">switch</span> result &#123;</span><br><span class="line">                <span class="comment">//数据拿到设置image</span></span><br><span class="line">                <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">self</span>.needsTransition(options: options, cacheType: value.cacheType) <span class="keyword">else</span> &#123;</span><br><span class="line">                        mutatingSelf.placeholder = <span class="literal">nil</span></span><br><span class="line">                        <span class="keyword">self</span>.base.image = value.image</span><br><span class="line">                        completionHandler?(result)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">self</span>.makeTransition(image: value.image, transition: options.transition) &#123;</span><br><span class="line">                        completionHandler?(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//任务失败</span></span><br><span class="line">                <span class="keyword">case</span> .failure:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> image = options.onFailureImage &#123;</span><br><span class="line">                        <span class="keyword">self</span>.base.image = image</span><br><span class="line">                    &#125;</span><br><span class="line">                    completionHandler?(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    mutatingSelf.imageTask = task</span><br><span class="line">    <span class="keyword">return</span> task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程大概是：</p><ul><li>UIImageView调用setImage设置图片</li><li>通过KingfisherManager.shared.retrieveImage获取图片</li><li>KingfisherManager.shared.retrieveImage去查内存缓存，有就返回，没有继续</li><li>KingfisherManager.shared.retrieveImage去查磁盘缓存，有就返回，没有继续</li><li>KingfisherManager.shared.loadAndCacheImage下载并缓存图片</li><li>查看图片中当前的任务和刚执行完的任务是不是同一个，同一个就设置图片，结束</li><li>不是同一个，就不处理，结束</li></ul><p>UIButton的setImage是类似的逻辑，就不多说了</p><p>这里需要特别说明的是在tableView中的处理，因为tableView中，快速上下滑动，cell重用。会导致一个UIImageView多次setImage。上面流程中的回设图片中会对比当前task和完成的task，如果不一致，说明这个是之前的某次setImage开启的下载完成了。这是一个对重用的处理细节。</p><p>另外当重新滑到之前的位置，setImage的url是开启的，并且没有下载完成，缓存中找不到。这个时候也不会立刻开始下载，而是去看下载任务队列中是否有该url的任务，找到之后，将这个任务绑定到这个UIImageView上。这也是重用的一个场景。</p><h2 id="多线程处理"><a href="#多线程处理" class="headerlink" title="多线程处理"></a>多线程处理</h2><p>库中会频繁用到网络请求和磁盘读写，为了不阻塞主线程，很显然需要用到多线程处理。使用URLSession，数据的返回默认会从异步执行。而磁盘的读写则需要我们自己处理，库中创建了一个处理<code>IO</code>的串行队列来处理。</p><p>因为这些异步处理，需要一些手段保证数据的一致性。下面列举一下临界区。</p><p><code>KingfisherManager</code>是一个单例，所有<code>UIImageView</code>，<code>UIButton</code>的<code>setImage</code>操作都是通过它来完成。<code>KingfisherManager</code>中有一个<code>ImageCache</code>和一个<code>downloader</code>。<code>cache</code>中的内存缓存是一个<code>NSCache</code>对象，全局的存取到会用到。</p><p><code>downloader</code>中下载会返回一个task，这些task会在sessionDelegate中管理。<code>private var tasks: [URL: SessionDataTask] = [:]</code></p><p><code>SessionDataTask</code>中保存了该任务的回调信息</p><p>多线程会导致一些同步问题，从网络下载完图片，会在未知线程缓存，接下来缓存时，有可能遇到其他任务正在读取缓存的情况。所以内存缓存的写入时加锁处理的。</p><p>库中多用队列来处理任务。流程中可能出现的多线程问题：</p><ul><li>同个文件的读写</li></ul><p>请求的起点一般是从<code>UIImageView.setImage</code>开始的，这个方法的调用一般是在主线程中发起。这个方法拿到数据后，<code>completionHandler</code>是通过<code>CallbackQueue.mainCurrentOrAsync</code>在主线程中执行。</p><p>在获取数据，会先查内存缓存，在查磁盘缓存。内存缓存的查询比较快，会在当前线程知节执行。磁盘缓存的查询，会使用一个单独的串行队列完成。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="Delegate-lt-Input-Output-gt"><a href="#Delegate-lt-Input-Output-gt" class="headerlink" title="Delegate&lt;Input, Output&gt;"></a>Delegate&lt;Input, Output&gt;</h4><p>Kingfisher 中使用Delegate类来包装block，添加<code>[weak self]</code>来避免 retain cycle。</p><p>class Delegate&lt;Input, Output&gt; {</p><p>​    init() {}    </p><p>​    private var block: ((Input) -&gt; Output?)?    </p><p>​    func delegate&lt;T: AnyObject&gt;(on target: T, block: ((T, Input) -&gt; Output)?) {</p><p>​        // The <code>target</code> is weak inside block, so you do not need to worry about it in the caller side.</p><p>​        self.block = { [weak target] input in</p><p>​            guard let target = target else { return nil }</p><p>​            return block?(target, input)</p><p>​        }</p><p>​    }</p><p>​    func call(_ input: Input) -&gt; Output? {</p><p>​        return block?(input)</p><p>​    }</p><p>}</p><p>delegate方法，将传入的block包装成自己的block，中间加入weak处理。call方法则是调用这个block。</p><h4 id="defer的使用"><a href="#defer的使用" class="headerlink" title="defer的使用"></a>defer的使用</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addCallback</span><span class="params">(<span class="number">_</span> callback: TaskCallback)</span></span> -&gt; <span class="type">CancelToken</span> &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">    callbacksStore[currentToken] = callback</span><br><span class="line">    <span class="keyword">defer</span> &#123; currentToken += <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> currentToken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个<code>defer</code>调用之后，返回的currentToken，值是+1之前的。<strong>所以deffer的调用时机，其实是返回之后。</strong></p><blockquote><p>从语言设计上来说，<code>defer</code> 的目的就是进行资源清理和避免重复的返回前需要执行的代码，而不是用来以取巧地实现某些功能。这样做只会让代码可读性降低。</p></blockquote><p>上边这段话是作者在<a href="https://onevcat.com/2018/11/defer/" target="_blank" rel="noopener">关于 Swift defer 的正确使用</a>中说的话，然后还是在kingfisher中用了。一个小趣点。</p><p>另外这篇文章中还提到了作用域的问题，<strong>defer这个词，并不是在方法返回后执行的。而是所在的作用域结束后返回的</strong>。比如你在if语句中写defer，那这个defer就是在if之后执行。不是在方法返回之后。文中有具体例子，可以细看。</p><p>这里使用了多个defer，之前没见过，查了下，<strong>多个defer的调用会以反序执行</strong>，类似入栈，出栈，网上有个很不错的例子，这里看一下。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> database = openDatabase(...) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">defer</span> &#123; closeDatabase(database) &#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> connection = openConnection(database) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125; </span><br><span class="line"><span class="keyword">defer</span> &#123; closeConnection(connection) &#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> result = runQuery(connection, ...) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br></pre></td></tr></table></figure><p>打开一个数据库，打开一个连接，结束之后，defer反序执行，先关掉连接，在关数据库。很恰当。</p><h4 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h4><p>库中对GCD的使用，是包装了一个<code>CallbackQueue</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CallbackQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> mainAsync</span><br><span class="line">    <span class="keyword">case</span> mainCurrentOrAsync</span><br><span class="line">    <span class="keyword">case</span> untouch</span><br><span class="line">    <span class="keyword">case</span> dispatch(<span class="type">DispatchQueue</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(<span class="number">_</span> block: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .mainAsync:</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123; block() &#125;</span><br><span class="line">        <span class="keyword">case</span> .mainCurrentOrAsync:</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.safeAsync &#123; block() &#125;</span><br><span class="line">        <span class="keyword">case</span> .untouch:</span><br><span class="line">            block()</span><br><span class="line">        <span class="keyword">case</span> .dispatch(<span class="keyword">let</span> queue):</span><br><span class="line">            queue.async &#123; block() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> queue: <span class="type">DispatchQueue</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .mainAsync: <span class="keyword">return</span> .main</span><br><span class="line">        <span class="keyword">case</span> .mainCurrentOrAsync: <span class="keyword">return</span> .main</span><br><span class="line">        <span class="keyword">case</span> .untouch: <span class="keyword">return</span> <span class="type">OperationQueue</span>.current?.underlyingQueue ?? .main</span><br><span class="line">        <span class="keyword">case</span> .dispatch(<span class="keyword">let</span> queue): <span class="keyword">return</span> queue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从execute的实现可以了解这几个枚举的含义。有一个是没出现过的，就是safeAsync。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This method will dispatch the `block` to self.</span></span><br><span class="line">    <span class="comment">// If `self` is the main queue, and current thread is main thread, the block</span></span><br><span class="line">    <span class="comment">// will be invoked immediately instead of being dispatched.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">safeAsync</span><span class="params">(<span class="number">_</span> block: @escaping <span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span> === <span class="type">DispatchQueue</span>.main &amp;&amp; <span class="type">Thread</span>.isMainThread &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            async &#123; block() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个safeAsync里会先判断当前是不是主队列和主线程。如果是主线程，主队列，就直接执行block，不然就async执行该block。这个方法只在上面的<code>mainCurrentOrAsync</code>由主队列调用，感觉这样写不是特别好，或者名字不是特别恰当。因为这个方法是加载DispatchQueue上的，所以其他队列也是可以调用的，但是非主队列调用，都是有问题的。这个方法的声明的范围太广了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块介绍&quot;&gt;&lt;a href=&quot;#模块介绍&quot; class=&quot;headerlink&quot; title=&quot;模块介绍&quot;&gt;&lt;/a&gt;模块介绍&lt;/h2&gt;&lt;h3 id=&quot;通用模块&quot;&gt;&lt;a href=&quot;#通用模块&quot; class=&quot;headerlink&quot; title=&quot;通用模块&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>rsa加密</title>
    <link href="http://yoursite.com/2019/06/26/rsa%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2019/06/26/rsa加密/</id>
    <published>2019-06-26T04:17:01.000Z</published>
    <updated>2019-06-28T14:36:01.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非对称加密算法-RSA（三位作者的名字首字母）"><a href="#非对称加密算法-RSA（三位作者的名字首字母）" class="headerlink" title="非对称加密算法 RSA（三位作者的名字首字母）"></a>非对称加密算法 RSA（三位作者的名字首字母）</h2><p>区别于对称加密算法，非对称加密算法采用两种密钥，公钥和私钥，公钥加密，私钥解密，反之也可以。私钥保留，公钥可以公开发布。</p><p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。</p><p>RSA生成密钥的过程用到欧拉函数，模反元素等，十分复杂。</p><ul><li>随机选择两个不相等的质数p和q</li><li>计算p和q的乘积n，上边说的密钥长度，就是n的长度</li><li>计算n的欧拉函数φ(n)</li><li>随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质</li><li>计算e对于φ(n)的模反元素d</li></ul><p>过程虽然复杂，但是一般也不需要特别清楚，我们只需知道计算过程用到了<code>p,q,n,e,d</code>，这些值封装在一起就是私钥，其中n和e封装在一起就是公钥。对计算过程感兴趣的可以看看阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA算法原理（一）</a>和<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA算法原理（二）</a>。</p><p>我们的数据，经过公钥中的n和e进行计算。计算出来的值，可以通过私钥中的n和d反解出来。</p><h2 id="密钥的形式"><a href="#密钥的形式" class="headerlink" title="密钥的形式"></a>密钥的形式</h2><h3 id="ASN-1"><a href="#ASN-1" class="headerlink" title="ASN.1"></a>ASN.1</h3><p>密钥中数据采用<a href="https://zh.wikipedia.org/wiki/ASN.1" target="_blank" rel="noopener">ASN.1</a>结构。ASN.1本身只定义了表示信息的抽象句法，但是没有限定其编码的方法。ASN.1有各种编码规则，其中密钥采用唯一编码规则（DER，Distinguished Encoding Rules）。用ASN.1表示法，公私钥大概是如下形式。</p><p>PublicKey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RSAPublicKey ::= SEQUENCE &#123;</span><br><span class="line">    modulus INTEGER, – n</span><br><span class="line">    publicExponent INTEGER – e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PrivateKey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RSAPrivateKey ::= SEQUENCE &#123;</span><br><span class="line">    version           Version,</span><br><span class="line">    modulus           INTEGER,  -- n</span><br><span class="line">    publicExponent    INTEGER,  -- e</span><br><span class="line">    privateExponent   INTEGER,  -- d</span><br><span class="line">    prime1            INTEGER,  -- p</span><br><span class="line">    prime2            INTEGER,  -- q</span><br><span class="line">    exponent1         INTEGER,  -- d mod (p-1)</span><br><span class="line">    exponent2         INTEGER,  -- d mod (q-1)</span><br><span class="line">    coefficient       INTEGER,  -- (inverse of q) mod p</span><br><span class="line">    otherPrimeInfos   OtherPrimeInfos OPTIONAL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DER-编码介绍"><a href="#DER-编码介绍" class="headerlink" title="DER 编码介绍"></a>DER 编码介绍</h3><p>DER编码会将数据编码成二机制形式。DER使用一种TLV格式来描述数据</p><img src="/2019/06/26/rsa加密/der-tlv-basic.png" title="tlv"><p><img src="rsa%E5%8A%A0%E5%AF%86/der-tlv-basic.png" alt></p><p>如果tag是容器类型，value就是另一组TLV了</p><img src="/2019/06/26/rsa加密/der-tlv-recursive.png" title="tlv-recursive"><p><img src="rsa%E5%8A%A0%E5%AF%86/der-tlv-recursive.png" alt></p><h4 id="tag编码"><a href="#tag编码" class="headerlink" title="tag编码"></a>tag编码</h4><p>tag一般占一个字节。前两位表示class类型，第三位表示原子类型还是结构体类型。</p><img src="/2019/06/26/rsa加密/der-tlv-tagbyte.png" title="tlv-tagbyte"><p><img src="rsa%E5%8A%A0%E5%AF%86/der-tlv-tagbyte.png" alt></p><p>具体类型编码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x01 == BOOLEAN</span><br><span class="line">0x02 == Integer</span><br><span class="line">0x03 == Bit String</span><br><span class="line">0x04 == Octet String</span><br><span class="line">0x05 == NULL</span><br><span class="line">0x06 == Object Identifier</span><br><span class="line"></span><br><span class="line">0x0C == UTF8String</span><br><span class="line">0x13 == PrintableString</span><br><span class="line">0x14 == TeletexString</span><br><span class="line">0x16 == IA5String</span><br><span class="line">0x1E == BMPString</span><br><span class="line"></span><br><span class="line">0x30 == SEQUENCE or SEQUENCE OF</span><br><span class="line">0x31 == SET or SET OF</span><br></pre></td></tr></table></figure><p>说明：所有的这些都是UNIVERSAl类型。因为前两位都是0。1E之前的都是primitive类型，因为第三位都是0。30和31是constructed类型，第三位是1。</p><h4 id="长度的约定"><a href="#长度的约定" class="headerlink" title="长度的约定"></a>长度的约定</h4><p>长度字段标示value字段的长度。如果value字段小于128字节，长度字段占一字节。并且字节第一位是0。如果value字段多于128个字节。那这一字节的第一位设置为1，接下来的位数表示需要几个字节来表示长度字段。</p><img src="/2019/06/26/rsa加密/der-tlv-lengthbyte.png" title="tlv-lengthbyte.png"><p><img src="rsa%E5%8A%A0%E5%AF%86/der-tlv-lengthbyte.png" alt></p><p>说明：为什么以128为界。因为默认情况下以一个字节表达长度，而这个字节的第一位用来标志是否溢出。所以只剩下7位用来表达长度。7位可以表达的最大数字是2的7次方128。所以以128为界。如果不用第一位来标志溢出，虽然可以表达256的长度，但是超过256就无法表达了。</p><h4 id="值的约定"><a href="#值的约定" class="headerlink" title="值的约定"></a>值的约定</h4><p>每个值都有一些特殊说明，全部列举比较繁杂，密钥中主要是用INTEGER类型和SEQUENCE类型，下面我们对这两种值类型进行一些说明。</p><h5 id="INTEGER"><a href="#INTEGER" class="headerlink" title="INTEGER"></a>INTEGER</h5><p>正常情况指定长度中的值就是编码后的值。</p><p>比如： 0x03，编码后为 0x02 0x01 0x03。类型，长度，值，很容易理解。</p><p>但是当一个正数，并且第一位是1的时候，需要做一些标示，来表明这个值是正值。标志很简单，就是在值前面加一个全0字节。</p><p>比如值 0x8F（10001111）首位是1</p><img src="/2019/06/26/rsa加密/der-tlv-integer.png" title="der-tlv-integer"><p><img src="/Users/mengbingchuan/workspace/blog/source/_posts/rsa%E5%8A%A0%E5%AF%86/der-tlv-integer.png" alt></p><p>0x02表明类型是INTEGER，长度两个字节，0x00表示是正数。0x8F就是这个值。</p><h5 id="SEQUENCE"><a href="#SEQUENCE" class="headerlink" title="SEQUENCE"></a>SEQUENCE</h5><p>SEQUENCE 包含一组有序的值。超过128位的情况，按照之前的长度约定走。例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">30 81 9f                             ; SEQUENCE (9f Bytes)</span><br><span class="line">|  30 0d                             ; SEQUENCE (d Bytes)</span><br><span class="line">|  |  |  06 09                       ; OBJECT_ID (9 Bytes)</span><br><span class="line">|  |  |  2a 86 48 86 f7 0d 01 01 01  ; 1.2.840.113549.1.1.1 </span><br><span class="line">|  |  05 00                          ; NULL (0 Bytes)</span><br><span class="line">|  03 81 8d                          ; BIT_STRING (8d Bytes)</span><br><span class="line">|     00</span><br><span class="line">|     30 81 89                       ; SEQUENCE (89 Bytes)</span><br><span class="line">|        02 81 81                    ; INTEGER (81 Bytes)</span><br><span class="line">|        |  00</span><br><span class="line">|        |  8f e2 41 2a 08 e8 51 a8  8c b3 e8 53 e7 d5 49 50</span><br><span class="line">|        |  b3 27 8a 2b cb ea b5 42  73 ea 02 57 cc 65 33 ee</span><br><span class="line">|        |  88 20 61 a1 17 56 c1 24  18 e3 a8 08 d3 be d9 31</span><br><span class="line">|        |  f3 37 0b 94 b8 cc 43 08  0b 70 24 f7 9c b1 8d 5d</span><br><span class="line">|        |  d6 6d 82 d0 54 09 84 f8  9f 97 01 75 05 9c 89 d4</span><br><span class="line">|        |  d5 c9 1e c9 13 d7 2a 6b  30 91 19 d6 d4 42 e0 c4</span><br><span class="line">|        |  9d 7c 92 71 e1 b2 2f 5c  8d ee f0 f1 17 1e d2 5f</span><br><span class="line">|        |  31 5b b1 9c bc 20 55 bf  3a 37 42 45 75 dc 90 65</span><br><span class="line">|        02 03                       ; INTEGER (3 Bytes)</span><br><span class="line">|           01 00 01</span><br></pre></td></tr></table></figure><p>外层SEQUENCE，81表示接下来1个字节表示长度，接下来的字节是9f，所以这个值占9f个字节。</p><p>内层SEQUENCE，0d，表示接下来d个字节是内容。</p><h4 id="密钥的表现形式"><a href="#密钥的表现形式" class="headerlink" title="密钥的表现形式"></a>密钥的表现形式</h4><p>接下来的分析，主要依据上边的编码介绍，可以对照着看。</p><p>密钥一般不是直接以der形式存在，大部分情况都会进行二次编码。比如下面这三个例子。</p><h5 id="openssl生成的私钥"><a href="#openssl生成的私钥" class="headerlink" title="openssl生成的私钥"></a>openssl生成的私钥</h5><p>使用openssl生成一个私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private_rsa.pem  1024</span><br></pre></td></tr></table></figure><p>使用base64解码，生成一个二机制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl   base64  -d  -in private_rsa.pem -out private</span><br></pre></td></tr></table></figure><p>可以用vim查看，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi -b private</span><br></pre></td></tr></table></figure><p>在vim中，将展示改成16进制<code>:%!xxd</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">00000000: 3082 025d 0201 0002 8181 00cc 9cd8 3a75  0..]..........:u</span><br><span class="line">00000010: 7080 3935 302a 3299 645c abbe 71b5 c3dd  p.950*2.d\..q...</span><br><span class="line">00000020: 5e3e 4421 409c 29ff 58c8 ff80 b2e5 6393  ^&gt;D!@.).X.....c.</span><br><span class="line">00000030: 13fe 6576 9f7f be6b 7c3a 80f6 0645 9bfc  ..ev...k|:...E..</span><br><span class="line">00000040: d878 6db5 8022 d929 2492 3f6c e69c 5603  .xm..&quot;.)$.?l..V.</span><br><span class="line">00000050: 46b0 60b1 69a7 4de8 ff40 7061 dc22 b279  F.`.i.M..@pa.&quot;.y</span><br><span class="line">00000060: c5b1 ccc5 d695 72cb 665f eada 0bed 9d27  ......r.f_.....&apos;</span><br><span class="line">00000070: 6e22 66e1 4d51 b3be 3393 2806 ea12 8927  n&quot;f.MQ..3.(....&apos;</span><br><span class="line">00000080: 454c e3a4 a9ca a5b3 80c7 ad02 0301 0001  EL..............</span><br><span class="line">00000090: 0281 800f 179a 9365 4a31 0b07 3350 497f  .......eJ1..3PI.</span><br><span class="line">000000a0: 2af9 f2e9 0f36 1b06 5f07 34bb 472a bda6  *....6.._.4.G*..</span><br><span class="line">000000b0: 4a04 3964 62cd acb4 928a f72c f2c2 d766  J.9db......,...f</span><br><span class="line">000000c0: d238 f67e 2f24 3f47 3d28 54df 485e 49aa  .8.~/$?G=(T.H^I.</span><br><span class="line">000000d0: 513a 4035 a265 02bd eb99 027a 214c 3a32  Q:@5.e.....z!L:2</span><br><span class="line">000000e0: 343b e023 77d2 3c24 4af1 6d12 1c79 5190  4;.#w.&lt;$J.m..yQ.</span><br><span class="line">000000f0: 1cbf 73a9 32b8 e9a7 1daa 5382 2f91 7c2d  ..s.2.....S./.|-</span><br><span class="line">00000100: b440 2c0d 31a4 85ee 72bb 7eae 03fb b895  .@,.1...r.~.....</span><br><span class="line">00000110: e812 8102 4100 e708 c31b 59bd 52cd fe3e  ....A.....Y.R..&gt;</span><br><span class="line">00000120: 130e ec2b 0b30 b983 17d3 843b d483 ba07  ...+.0.....;....</span><br><span class="line">00000130: b46a 911c 9f7e 6df5 9cdc cc04 dfe9 d5cf  .j...~m.........</span><br><span class="line">00000140: 6e8e 7401 5e8d b5d4 cb41 4fa9 1093 d8c4  n.t.^....AO.....</span><br><span class="line">00000150: de0d 4b1e 51b1 0241 00e2 b92a d49d 8ccf  ..K.Q..A...*....</span><br><span class="line">00000160: bf3a f78e 2133 c6db bac4 6af5 4414 d514  .:..!3....j.D...</span><br><span class="line">00000170: 7791 6491 b2e3 a1ca 91e1 d88f 6f1e 1f25  w.d.........o..%</span><br><span class="line">00000180: d42f deb6 5b3e 85c7 b467 df10 7040 3877  ./..[&gt;...g..p@8w</span><br><span class="line">00000190: 205f 3059 c3da 6bf8 bd02 4046 9520 b65c   _0Y..k...@F. .\</span><br><span class="line">000001a0: 6640 c3fa 2690 c000 5aee 2246 aacc 3eac  f@..&amp;...Z.&quot;F..&gt;.</span><br><span class="line">000001b0: a972 b583 c212 d673 dae0 c749 64be 359e  .r.....s...Id.5.</span><br><span class="line">000001c0: 86e6 b993 beb9 b1ff b2e3 663b e4f4 ebd1  ..........f;....</span><br><span class="line">000001d0: 207f 960b a5a9 893a 27db 2102 4100 9527   ......:&apos;.!.A..&apos;</span><br><span class="line">000001e0: b258 bbe9 8646 cd59 4d64 e476 3fda 281c  .X...F.YMd.v?.(.</span><br><span class="line">000001f0: 218d 0f93 7aea 8a79 3a2d 10fa 4095 269a  !...z..y:-..@.&amp;.</span><br><span class="line">00000200: 5d0a 822b 85ac 896d a054 78d6 7422 686f  ]..+...m.Tx.t&quot;ho</span><br><span class="line">00000210: 6496 2479 c14d 47b2 3c6b cfc7 5695 0241  d.$y.MG.&lt;k..V..A</span><br><span class="line">00000220: 00a9 9a8c 20ac a6fb 5a17 8df8 e118 397d  .... ...Z.....9&#125;</span><br><span class="line">00000230: 22bc 706a 47cb 9d11 2f4d a4e5 708c 044d  &quot;.pjG.../M..p..M</span><br><span class="line">00000240: 1f4a 6870 3365 a8df 0c1b 440f 12c7 86de  .Jhp3e....D.....</span><br><span class="line">00000250: 4246 0b99 3c9e f01f 2313 b0bf 894b aaa1  BF..&lt;...#....K..</span><br><span class="line">00000260: 58</span><br></pre></td></tr></table></figure><p>接下来比较长，比较乏味，我将生成的私钥进行了简单的格式处理，我们看看是不是符合ASN.1中对私钥的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># VERSION</span><br><span class="line">0201 00 </span><br><span class="line"></span><br><span class="line"># modulus INTEGER,  -- n</span><br><span class="line">02 8181</span><br><span class="line">00cc 9cd8 3a75</span><br><span class="line">7080 3935 302a 3299 645c abbe 71b5 c3dd 5e3e 4421 409c 29ff 58c8 ff80 b2e5 6393</span><br><span class="line">13fe 6576 9f7f be6b 7c3a 80f6 0645 9bfc d878 6db5 8022 d929 2492 3f6c e69c 5603</span><br><span class="line">46b0 60b1 69a7 4de8 ff40 7061 dc22 b279 c5b1 ccc5 d695 72cb 665f eada 0bed 9d27</span><br><span class="line">6e22 66e1 4d51 b3be 3393 2806 ea12 8927 454c e3a4 a9ca a5b3 80c7 ad</span><br><span class="line"></span><br><span class="line"># publicExponent INTEGER,  -- e 65537</span><br><span class="line">02 0301 0001</span><br><span class="line"></span><br><span class="line"># privateExponent INTEGER,  -- d</span><br><span class="line">0281 80</span><br><span class="line">0f 179a 9365 4a31 0b07 3350 497f 2af9 f2e9 0f36 1b06 5f07 34bb 472a bda6</span><br><span class="line">4a04 3964 62cd acb4 928a f72c f2c2 d766 d238 f67e 2f24 3f47 3d28 54df 485e 49aa</span><br><span class="line">513a 4035 a265 02bd eb99 027a 214c 3a32 343b e023 77d2 3c24 4af1 6d12 1c79 5190</span><br><span class="line">1cbf 73a9 32b8 e9a7 1daa 5382 2f91 7c2d b440 2c0d 31a4 85ee 72bb 7eae 03fb b895 e812 81</span><br><span class="line"></span><br><span class="line"># prime1            INTEGER,  -- p</span><br><span class="line">02 41</span><br><span class="line">00 </span><br><span class="line">e708 c31b 59bd 52cd fe3e 130e ec2b 0b30 b983 17d3 843b d483 ba07</span><br><span class="line">b46a 911c 9f7e 6df5 9cdc cc04 dfe9 d5cf 6e8e 7401 5e8d b5d4 cb41 4fa9 1093 d8c4</span><br><span class="line">de0d 4b1e 51b1 </span><br><span class="line"></span><br><span class="line"># prime2            INTEGER,  -- q</span><br><span class="line">0241 </span><br><span class="line">00</span><br><span class="line">e2 b92a d49d 8ccf bf3a f78e 2133 c6db bac4 6af5 4414 d514</span><br><span class="line">7791 6491 b2e3 a1ca 91e1 d88f 6f1e 1f25 d42f deb6 5b3e 85c7 b467 df10 7040 3877</span><br><span class="line">205f 3059 c3da 6bf8 bd</span><br><span class="line"></span><br><span class="line"># exponent1         INTEGER,  -- d mod (p-1)</span><br><span class="line">02 40</span><br><span class="line">46 9520 b65c</span><br><span class="line">6640 c3fa 2690 c000 5aee 2246 aacc 3eac a972 b583 c212 d673 dae0 c749 64be 359e</span><br><span class="line">86e6 b993 beb9 b1ff b2e3 663b e4f4 ebd1 207f 960b a5a9 893a 27db 21</span><br><span class="line"></span><br><span class="line"># exponent2         INTEGER,  -- d mod (q-1)</span><br><span class="line">02 41</span><br><span class="line">00 </span><br><span class="line">9527 b258 bbe9 8646 cd59 4d64 e476 3fda 281c 218d 0f93 7aea 8a79 3a2d 10fa 4095 269a</span><br><span class="line">5d0a 822b 85ac 896d a054 78d6 7422 686f 6496 2479 c14d 47b2 3c6b cfc7 5695 </span><br><span class="line"></span><br><span class="line"># coefficient       INTEGER,  -- (inverse of q) mod p</span><br><span class="line">0241</span><br><span class="line">00</span><br><span class="line">a9 9a8c 20ac a6fb 5a17 8df8 e118 397d 22bc 706a 47cb 9d11 2f4d a4e5 708c 044d</span><br><span class="line">1f4a 6870 3365 a8df 0c1b 440f 12c7 86de 4246 0b99 3c9e f01f 2313 b0bf 894b aaa1 58</span><br></pre></td></tr></table></figure><p>可以看到，私钥中的数据在这里面有完整的对应。</p><h5 id="服务端给的公钥，待补充：这个公钥的类型是什么？"><a href="#服务端给的公钥，待补充：这个公钥的类型是什么？" class="headerlink" title="服务端给的公钥，待补充：这个公钥的类型是什么？"></a>服务端给的公钥，待补充：这个公钥的类型是什么？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCBzf/UKYSGEZNn0ziH8ZhcSmIJ</span><br><span class="line">bVIzGx95BW2URGzpuNDUbdX55mOMPO9Arw/j5zh1kPG5fVq0BcZMFkYhIOn4+6kj</span><br><span class="line">awVpjnNzCvvj2//csftaKyyFslvKPf1Gu3kd/OTVKg93L0kL+SFmPtqI1RT6HUqK</span><br><span class="line">4N6Ht24bia11kkgnewIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><p>格式化后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3081 9f //9f长度的SEQUENCE数据</span><br><span class="line">30 0d   //d 长度的SEQUENCE数据</span><br><span class="line">06 09 2a 8648 86f7 0d01 0101 //9 长度的 Object Identifier数据 1.2.840.113549.1.1.1</span><br><span class="line">0500 //结尾的NULL</span><br><span class="line">0381 8d  //8d长度的 Bit String 数据</span><br><span class="line">00 </span><br><span class="line">3081 8902 8181 0081 cdff</span><br><span class="line">d429 8486 1193 67d3 3887 f198 5c4a 6209</span><br><span class="line">6d52 331b 1f79 056d 9444 6ce9 b8d0 d46d</span><br><span class="line">d5f9 e663 8c3c ef40 af0f e3e7 3875 90f1</span><br><span class="line">b97d 5ab4 05c6 4c16 4621 20e9 f8fb a923</span><br><span class="line">6b05 698e 7373 0afb e3db ffdc b1fb 5a2b</span><br><span class="line">2c85 b25b ca3d fd46 bb79 1dfc e4d5 2a0f</span><br><span class="line">772f 490b f921 663e da88 d514 fa1d 4a8a</span><br><span class="line">e0de 87b7 6e1b 89ad 7592 4827 7b02 0301 </span><br><span class="line">00 01</span><br></pre></td></tr></table></figure><p>头信息很长，首先是一个SEQUNENCE开头，里面有一个SEQUNENCE和一个Bit String。</p><p>内部的这个SEQUNENCE包装了两个数据，一个对象标识，一个空数据结尾，这个对象标识解出来是<code>1.2.840.113549.1.1.1</code>,对应的名字是<code>szOID_RSA_RSA</code>。这是加密算法标识符，有很多类型，这个类型表示，RSA既可以用于加密，也可以用于给数据签名。详细信息可以<a href="https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/ns-wincrypt-_crypt_algorithm_identifier" target="_blank" rel="noopener">参考</a>。</p><p>Bit String中放的数据就是我们的公钥了，下面看看这个公钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">30 81 89</span><br><span class="line"></span><br><span class="line">02 81 81 </span><br><span class="line">0081 cdff</span><br><span class="line">d429 8486 1193 67d3 3887 f198 5c4a 6209</span><br><span class="line">6d52 331b 1f79 056d 9444 6ce9 b8d0 d46d</span><br><span class="line">d5f9 e663 8c3c ef40 af0f e3e7 3875 90f1</span><br><span class="line">b97d 5ab4 05c6 4c16 4621 20e9 f8fb a923</span><br><span class="line">6b05 698e 7373 0afb e3db ffdc b1fb 5a2b</span><br><span class="line">2c85 b25b ca3d fd46 bb79 1dfc e4d5 2a0f</span><br><span class="line">772f 490b f921 663e da88 d514 fa1d 4a8a</span><br><span class="line">e0de 87b7 6e1b 89ad 7592 4827 7b</span><br><span class="line"></span><br><span class="line">02 03 </span><br><span class="line">01 00 01</span><br></pre></td></tr></table></figure><p>以SEQUNENCE作为容器，里面有两个Integer，一个是129个字节的n，一个是e 65537。</p><h5 id="sshkeygen生成的公钥"><a href="#sshkeygen生成的公钥" class="headerlink" title="sshkeygen生成的公钥"></a>sshkeygen生成的公钥</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00000000: 0000 0007 7373 682d 7273 6100 0000 0301  ....ssh-rsa.....</span><br><span class="line">00000010: 0001 0000 0101 00a0 f5d6 20a3 2ff7 6106  .......... ./.a.</span><br><span class="line">00000020: d301 e98a d7a8 6307 bc30 74e8 5668 d7b0  ......c..0t.Vh..</span><br><span class="line">00000030: 80a8 0f8d c1c0 c495 53f4 e016 ec17 26d1  ........S.....&amp;.</span><br><span class="line">00000040: 1635 bfe6 0a60 6174 1a9c dcef 176e 0fb7  .5...`at.....n..</span><br><span class="line">00000050: bd66 a939 25ce 1a56 c446 e3c5 1c31 b894  .f.9%..V.F...1..</span><br><span class="line">00000060: c17f db57 bd4e 88bc b3a8 5c95 919c 2394  ...W.N....\...#.</span><br><span class="line">00000070: 39d0 254b ecac 94fb 7d69 ec1c 143a 434f  9.%K....&#125;i...:CO</span><br><span class="line">00000080: d6a8 4572 eaf6 aef3 3d5e 7899 4ba5 739d  ..Er....=^x.K.s.</span><br><span class="line">00000090: 45d6 d928 b506 93fd 41ae d3f8 1149 92ac  E..(....A....I..</span><br><span class="line">000000a0: f483 a853 22cc ac09 ee5f 76ff 36b6 0424  ...S&quot;...._v.6..$</span><br><span class="line">000000b0: 2dce 9ea1 be1b 92aa 73b6 f1cf 22dc f304  -.......s...&quot;...</span><br><span class="line">000000c0: e146 50ad 472d 4885 9d67 160c fac7 b2e8  .FP.G-H..g......</span><br><span class="line">000000d0: 915b 925c 979f 54b3 2934 269d 28e2 e88b  .[.\..T.)4&amp;.(...</span><br><span class="line">000000e0: 202d c95c a8c8 66af 5784 6cf2 269e abc6   -.\..f.W.l.&amp;...</span><br><span class="line">000000f0: 1bf0 5531 66a4 72fc d10b 9237 00e0 9b17  ..U1f.r....7....</span><br><span class="line">00000100: d2ab 7bf0 a135 0b37 d399 6731 eb83 6f2e  ..&#123;..5.7..g1..o.</span><br><span class="line">00000110: a49c 84c0 9781 63</span><br></pre></td></tr></table></figure><p>这个有点尴尬，好像不是der的编码格式。而且，第一行还显示出了ssh-rsa。这个格式没找到对应的编码介绍，网上有人翻译，看翻译过程，这个编码格式像是简化了的der。可能因为信息类型确定，长度也相对确定，所以省掉了tag，以及长度溢出的措施，这里应该是LV格式，即长度-值。长度占4个字节。我们用这个规则看一下上面的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000 0007 //长度 7</span><br><span class="line">7373 682d 7273 61 //ascii码：ssh-rsa</span><br><span class="line">0000 0003  //长度 3</span><br><span class="line">010001     // e 65537</span><br><span class="line">0000 0101  //长度256</span><br><span class="line">//下面的256个字节，n</span><br><span class="line">00 a0 f5d6 20a3 2ff7 6106</span><br><span class="line">d301 e98a d7a8 6307 bc30 74e8 5668 d7b0</span><br><span class="line">80a8 0f8d c1c0 c495 53f4 e016 ec17 26d1</span><br><span class="line">1635 bfe6 0a60 6174 1a9c dcef 176e 0fb7</span><br><span class="line">bd66 a939 25ce 1a56 c446 e3c5 1c31 b894</span><br><span class="line">c17f db57 bd4e 88bc b3a8 5c95 919c 2394</span><br><span class="line">39d0 254b ecac 94fb 7d69 ec1c 143a 434f</span><br><span class="line">d6a8 4572 eaf6 aef3 3d5e 7899 4ba5 739d</span><br><span class="line">45d6 d928 b506 93fd 41ae d3f8 1149 92ac</span><br><span class="line">f483 a853 22cc ac09 ee5f 76ff 36b6 0424</span><br><span class="line">2dce 9ea1 be1b 92aa 73b6 f1cf 22dc f304</span><br><span class="line">e146 50ad 472d 4885 9d67 160c fac7 b2e8</span><br><span class="line">915b 925c 979f 54b3 2934 269d 28e2 e88b</span><br><span class="line">202d c95c a8c8 66af 5784 6cf2 269e abc6</span><br><span class="line">1bf0 5531 66a4 72fc d10b 9237 00e0 9b17</span><br><span class="line">d2ab 7bf0 a135 0b37 d399 6731 eb83 6f2e</span><br><span class="line">a49c 84c0 9781 63</span><br></pre></td></tr></table></figure><p>这个数据表达了三个信息，类型ssh-rsa，e 65537，n那一大串数。</p><p>ssh-keygen生成的公钥id_rsa.pub，可以通过命令<code>ssh-keygen -f key.pub -e -m pem</code>转成标准der格式。</p><p>比如上面那个公钥经过这个命令之后是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00000000: 3082 010a 0282 0101 00a0 f5d6 20a3 2ff7  0........... ./.</span><br><span class="line">00000010: 6106 d301 e98a d7a8 6307 bc30 74e8 5668  a.......c..0t.Vh</span><br><span class="line">00000020: d7b0 80a8 0f8d c1c0 c495 53f4 e016 ec17  ..........S.....</span><br><span class="line">00000030: 26d1 1635 bfe6 0a60 6174 1a9c dcef 176e  &amp;..5...`at.....n</span><br><span class="line">00000040: 0fb7 bd66 a939 25ce 1a56 c446 e3c5 1c31  ...f.9%..V.F...1</span><br><span class="line">00000050: b894 c17f db57 bd4e 88bc b3a8 5c95 919c  .....W.N....\...</span><br><span class="line">00000060: 2394 39d0 254b ecac 94fb 7d69 ec1c 143a  #.9.%K....&#125;i...:</span><br><span class="line">00000070: 434f d6a8 4572 eaf6 aef3 3d5e 7899 4ba5  CO..Er....=^x.K.</span><br><span class="line">00000080: 739d 45d6 d928 b506 93fd 41ae d3f8 1149  s.E..(....A....I</span><br><span class="line">00000090: 92ac f483 a853 22cc ac09 ee5f 76ff 36b6  .....S&quot;...._v.6.</span><br><span class="line">000000a0: 0424 2dce 9ea1 be1b 92aa 73b6 f1cf 22dc  .$-.......s...&quot;.</span><br><span class="line">000000b0: f304 e146 50ad 472d 4885 9d67 160c fac7  ...FP.G-H..g....</span><br><span class="line">000000c0: b2e8 915b 925c 979f 54b3 2934 269d 28e2  ...[.\..T.)4&amp;.(.</span><br><span class="line">000000d0: e88b 202d c95c a8c8 66af 5784 6cf2 269e  .. -.\..f.W.l.&amp;.</span><br><span class="line">000000e0: abc6 1bf0 5531 66a4 72fc d10b 9237 00e0  ....U1f.r....7..</span><br><span class="line">000000f0: 9b17 d2ab 7bf0 a135 0b37 d399 6731 eb83  ....&#123;..5.7..g1..</span><br><span class="line">00000100: 6f2e a49c 84c0 9781 6302 0301 0001       o.......c.....</span><br></pre></td></tr></table></figure><p>这个就很熟悉了，标准的TLV格式。SEQUNENCE下两个INTEGER，n和e。</p><h4 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h4><p>密钥的格式只见到过这几种，就对这几种进行了分析。还需要看看总共有多少种，如何分类，以及为什么这么分类。</p><p><strong>参考</strong></p><p><a href="http://github.tiankonguse.com/blog/2017/07/01/ASN1-SRA.html" target="_blank" rel="noopener">解读RSA公钥私钥储存格式</a></p><p><a href="https://stackoverflow.com/questions/12749858/rsa-public-key-format" target="_blank" rel="noopener">stackoverflow</a></p><p><a href="https://blog.oddbit.com/post/2011-05-08-converting-openssh-public-keys/" target="_blank" rel="noopener">CONVERTING OPENSSH PUBLIC KEYS</a></p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/seccertenroll/distinguished-encoding-rules" target="_blank" rel="noopener">DER 编码</a></p><p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA 算法原理</a></p><p><a href="https://serverfault.com/questions/9708/what-is-a-pem-file-and-how-does-it-differ-from-other-openssl-generated-key-file" target="_blank" rel="noopener">各类证书格式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非对称加密算法-RSA（三位作者的名字首字母）&quot;&gt;&lt;a href=&quot;#非对称加密算法-RSA（三位作者的名字首字母）&quot; class=&quot;headerlink&quot; title=&quot;非对称加密算法 RSA（三位作者的名字首字母）&quot;&gt;&lt;/a&gt;非对称加密算法 RSA（三位作者的
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS内存介绍</title>
    <link href="http://yoursite.com/2019/03/23/iOS%E5%86%85%E5%AD%98%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/03/23/iOS内存介绍/</id>
    <published>2019-03-23T05:00:23.000Z</published>
    <updated>2019-06-25T09:05:14.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>iOS 启动，会先在内存空间中开辟一块区域，然后将这块区域内部划分成如下部分。</p><img src="/2019/03/23/iOS内存介绍/memory.png" title="This is an example image"><p>图中与我们相关性较大的是栈区和堆区。栈区一般是存放方法栈。堆区存放开发者创建的对象。通常我们说的内存管理，就是指的堆中的内存管理。</p><h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>iOS中采用引用计数的方式管理内存，每多一个强引用，引用计数就加一，销毁一个强引用，引用计数就减一。引用计数为0时，会触发dealloc方法，释放该对象。下面将要介绍的东西都是在引用技术基础上做的内存管理。</p><h1 id="内存相关结构与操作"><a href="#内存相关结构与操作" class="headerlink" title="内存相关结构与操作"></a>内存相关结构与操作</h1><h2 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h2><p>引用计数涉及到的数据结构有isa指针，sidetables，sidetable，weaktable等。</p><p>isa指针中有几位是用来存储该对象被引用的次数的。但是因为位数有限，能表达的数量很有限，当不够表达时，isa中还有一位用来标记是否额外存储。如果标记是1，表示该对象的引用计数还存储在sidetables中。</p><p>sidetables由64个sidetable组成。通过hash算法定位。因为这些表是全局共享，会频繁的并发读写，如果只有一个表，多个线程同时操作时，要等很久。分表后可以大大减少多个线程同时操作一个表的情况，提高性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保证原子操作的自旋锁</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    <span class="comment">// 引用计数的 hash 表</span></span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="comment">// weak 引用全局 hash 表</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用计数表以对象指针为key，以引用计数+两个标记位 为value。因为后两个标记位所以，当引用计数需要加减的时候，是从第三位开始。</p><p>weak表以对象指针为key，以引用地址的数组为key，没增加一个weak引用，就添加到这个数组中。</p><p>retain，relase等相关的操作都是针对这些结构的添加修改删除。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><strong>retainCount</strong></p><p>retainCount比较简单，根据对象地址找到sidetable，然后继续在RefCountmap中找到计数并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> refcnt_result = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">return</span> refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>retain</strong><br>retain操作会对引用计数加1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">table.lock();</span><br><span class="line">size_t&amp; refcntStorage = table.refcnts[this];</span><br><span class="line">if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">&#125;</span><br><span class="line">table.unlock();</span><br><span class="line"></span><br><span class="line">return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release 自动引用减一，减到0，会调用SEL_dealloc，触发dealloc。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release(bool performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">bool do_dealloc = false;</span><br><span class="line"></span><br><span class="line">table.lock();</span><br><span class="line">RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">if (it == table.refcnts.end()) &#123;</span><br><span class="line">do_dealloc = true;</span><br><span class="line">table.refcnts[this] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">&#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&apos;t change it.</span><br><span class="line">do_dealloc = true;</span><br><span class="line">it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">&#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">&#125;</span><br><span class="line">table.unlock();</span><br><span class="line">if (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">&#125;</span><br><span class="line">return do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dealloc 注释有说明，如果没有额外处理，就直接free，不然先通过object_dispose处理若引用，关联属性等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">assert(!UseGC);</span><br><span class="line">if (isTaggedPointer()) return;</span><br><span class="line"></span><br><span class="line">//指针型isa &amp;&amp; 没被弱引用&amp;&amp;没有关联属性&amp;&amp;没有c++创建&amp;&amp;没有用引用计数表</span><br><span class="line">if (isa.indexed  &amp;&amp;  </span><br><span class="line">!isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">!isa.has_assoc  &amp;&amp;  </span><br><span class="line">!isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">!isa.has_sidetable_rc)</span><br><span class="line">&#123;</span><br><span class="line">assert(!sidetable_present());</span><br><span class="line">//直接释放</span><br><span class="line">free(this);</span><br><span class="line">&#125; </span><br><span class="line">else &#123;</span><br><span class="line">object_dispose((id)this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispose会调用destructInstance，这个方法如下，注释有说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">if (obj) &#123;</span><br><span class="line">// Read all of the flags at once for performance.</span><br><span class="line">bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class="line">bool dealloc = !UseGC;</span><br><span class="line"></span><br><span class="line">// This order is important.</span><br><span class="line">//调用c++的销毁方法</span><br><span class="line">if (cxx) object_cxxDestruct(obj);</span><br><span class="line">//移除关联属性</span><br><span class="line">if (assoc) _object_remove_assocations(obj);</span><br><span class="line">//清理引用计数表和weak表</span><br><span class="line">if (dealloc) obj-&gt;clearDeallocating();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是clearDeallocating，主要是处理引用计数表和弱引用表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">if (!isa.indexed) &#123;</span><br><span class="line">// Slow path for raw pointer isa.</span><br><span class="line">//清理引用计数表</span><br><span class="line">sidetable_clearDeallocating();</span><br><span class="line">&#125;</span><br><span class="line">else if (isa.weakly_referenced  ||  isa.has_sidetable_rc) &#123;</span><br><span class="line">// Slow path for non-pointer isa with weak refs and/or side table data.</span><br><span class="line">clearDeallocating_slow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h1><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><p>autoreleasepool通过<code>AutoreleasePoolPage</code>管理对象，每个线程有一个page，存储在TLS中。page内部以栈的方式组织，大小位4096字节，对应操作系统的内存页。每次添加对象就通过page的压栈存入，存满会创建一个新的page继续存储，page与page通过链表的方式存储。push操作会将一个哨兵（nil）压栈，并返回这个位置的地址。pop会查找这个地址，将栈顶到该位置的对象都release。多次的autoreleasepool，会有多个push，记录多个哨兵的位置，然后pop时pop到对应的位置。</p><h2 id="autoreleasepool的实现"><a href="#autoreleasepool的实现" class="headerlink" title="autoreleasepool的实现"></a>autoreleasepool的实现</h2><p>我们通常使用自动释放池就是使用<code>@autoreleasepool{}</code>，这个block对应一个结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">__AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构题会在初始化的时候调用<code>objc_autoreleasePoolPush</code>，在析构时调用<code>objc_autoreleasePoolPop</code>。我们在objc源码中找到这两个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">if (UseGC) return nil;</span><br><span class="line">return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">if (UseGC) return;</span><br><span class="line">AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是<code>AutoreleasePoolPage</code>这个类来实现的。<br>直接从这两个方法看起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//添加哨兵POOL_SENTINEL（值为nil），处理page，返回哨兵对象的地址。</span><br><span class="line">static inline void *push() </span><br><span class="line">&#123;</span><br><span class="line">id *dest;</span><br><span class="line">if (DebugPoolAllocation) &#123;</span><br><span class="line">// Each autorelease pool starts on a new pool page.</span><br><span class="line">dest = autoreleaseNewPage(POOL_SENTINEL);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dest = autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">&#125;</span><br><span class="line">assert(*dest == POOL_SENTINEL);</span><br><span class="line">return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下怎么处理的poolpage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">AutoreleasePoolPage *page = hotPage();</span><br><span class="line">if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">return page-&gt;add(obj);</span><br><span class="line">&#125; else if (page) &#123;</span><br><span class="line">return autoreleaseFullPage(obj, page);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return autoreleaseNoPage(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到当前page，如果能拿到并且，page没有存满，就将obj存入<br>如果page是满的，就走autoreleaseFullPage<br>如果没拿到page，走autoreleaseNoPage方法</p><p>接着看下hotPage()是怎么处理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline AutoreleasePoolPage *hotPage() </span><br><span class="line">&#123;</span><br><span class="line">AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">tls_get_direct(key);</span><br><span class="line">if (result) result-&gt;fastcheck();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个page是放到线程的存储空间的，所以poolpage是线程相关的，一个线程，一个page链。</p><p>没有page时，第一次创建成功会将hotpage存起来，会存到线程中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void setHotPage(AutoreleasePoolPage *page) </span><br><span class="line">&#123;</span><br><span class="line">if (page) page-&gt;fastcheck();</span><br><span class="line">tls_set_direct(key, (void *)page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此push就差不多了，总结下push都干了什么</p><ul><li>从线程的存储空间中拿到当前页（hotpage），没有的话，就创建一个放进去</li><li>查看page有没有满，没满就将传入的哨兵存入。</li><li>page满了，向链中寻找最后一个节点，创建一个新的page，parent设置为这个节点，将这个节点设置为hotpage。</li></ul><p>接下来看看pop</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static inline void pop(void *token) </span><br><span class="line">&#123;</span><br><span class="line">AutoreleasePoolPage *page;</span><br><span class="line">id *stop;</span><br><span class="line">//token是一个地址，要pop到这个地址为止。</span><br><span class="line">//找到这个地址所在的page</span><br><span class="line">page = pageForPointer(token);</span><br><span class="line">stop = (id *)token;</span><br><span class="line">//释放对象到指定的地址</span><br><span class="line">page-&gt;releaseUntil(stop);</span><br><span class="line">//移除空的page</span><br><span class="line">// memory: delete empty children</span><br><span class="line">if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">// special case: delete everything during page-per-pool debugging</span><br><span class="line">AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">page-&gt;kill();</span><br><span class="line">//重置hotpage</span><br><span class="line">setHotPage(parent);</span><br><span class="line">&#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">// special case: delete everything for pop(top) </span><br><span class="line">// when debugging missing autorelease pools</span><br><span class="line">//删光了，就没了</span><br><span class="line">page-&gt;kill();</span><br><span class="line">setHotPage(nil);</span><br><span class="line">&#125; </span><br><span class="line">else if (page-&gt;child) &#123;</span><br><span class="line">//如果当前page已经用了超过一半了，就保留一个空的page</span><br><span class="line">// hysteresis: keep one empty child if page is more than half full</span><br><span class="line">if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">page-&gt;child-&gt;kill();</span><br><span class="line">&#125;</span><br><span class="line">else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop操作和push是成对操作，push操作记录的位置，接下来会用来pop。</p><h2 id="runtime对autorelease返回值的优化"><a href="#runtime对autorelease返回值的优化" class="headerlink" title="runtime对autorelease返回值的优化"></a>runtime对autorelease返回值的优化</h2><p><strong>问题1:为什么要做这个优化？</strong></p><p>答：<br>当返回值被返回之后，紧接着就需要被 retain 的时候，没有必要进行 autorelease + retain，直接什么都不要做就好了。</p><p><strong>问题2:如何做的优化？</strong></p><p>基本思路：</p><p>在返回值身上调用<code>objc_autoreleaseReturnValue</code>方法时，runtime在TLS中做一个标记，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的objc_retainAutoreleasedReturnValue里，发现TLS中有标记，那么直接返回这个object（不调用retain）。<br>于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。</p><p>具体做法：<br>优化主要是通过两个方法进行实现<code>objc_autoreleaseReturnValue</code>和<code>objc_retainAutoreleasedReturnValue</code></p><p>看第一个方法前，先看个枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum ReturnDisposition : bool &#123;</span><br><span class="line">ReturnAtPlus0 = false, ReturnAtPlus1 = true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>objc_autoreleaseReturnValue</code></strong></p><p>方法的实现如下，通过注释进行了解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Prepare a value at +1 for return through a +0 autoreleasing convention.</span><br><span class="line">id objc_autoreleaseReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">//可被优化的场景下，直接返回obj</span><br><span class="line">if (prepareOptimizedReturn(ReturnAtPlus1)) return obj;</span><br><span class="line">//否则还是使用autorelease</span><br><span class="line">return objc_autorelease(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对可优化场景的判断，在<code>prepareOptimizedReturn</code>方法中，参数我们根据上边的枚举已经得知<br><code>ReturnAtPlus1</code>是<code>true</code>,看下这个方法的实现，用注释做了说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE bool </span><br><span class="line">prepareOptimizedReturn(ReturnDisposition disposition)</span><br><span class="line">&#123;</span><br><span class="line">//如果调用方符合优化条件，就返回true，表示这次调用可以被优化</span><br><span class="line">if (callerAcceptsOptimizedReturn(__builtin_return_address(0))) &#123;</span><br><span class="line">//设置dispostion，为后续的objc_retainAutoreleasedReturnValue准备</span><br><span class="line">if (disposition) setReturnDisposition(disposition);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">//不符合条件，不做优化</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setReturnDisposition</code>是在TLS中存入标记，后续的<code>objc_retainAutoreleasedReturnValue</code>会从TLS中读取来判断，之前是否已经做过了优化。这里比较复杂的方法是<code>callerAcceptsOptimizedReturn</code>判断调用方是否接受一个优化的结果。方法的实现比较难以理解，但是注释说明的比较清楚。</p><blockquote><p>Callee looks for <code>mov rax, rdi</code> followed by a call or<br>jump instruction to objc_retainAutoreleasedReturnValue or<br>objc_unsafeClaimAutoreleasedReturnValue. </p></blockquote><p>接收方为上述的两种情况时，调用方就符合优化条件。这个条件其实是判断，是否MRC和ARC混编，如果调用方和被调方一个使用MRC一个使用ARC，就不能做这个优化了。</p><p><strong><code>objc_retainAutoreleasedReturnValue</code></strong></p><p>这个方法相对简单，就是判断之前是否已经做了优化（通过TLS中的<code>RETURN_DISPOSITION_KEY</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Accept a value returned through a +0 autoreleasing convention for use at +1.</span><br><span class="line">id objc_retainAutoreleasedReturnValue(id obj)</span><br><span class="line">&#123;   //从TLS中获取RETURN_DISPOSITION_KEY对应的值，为true，就直接返回obj。</span><br><span class="line">//读取完之后，重置为false</span><br><span class="line">if (acceptOptimizedReturn() == ReturnAtPlus1) return obj;</span><br><span class="line">//没有优化，就走正常的retain流程</span><br><span class="line">return objc_retain(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法成对使用，就可以省去将对象添加到autoreleasepool中的操作。</p><h1 id="一个对象的内存布局"><a href="#一个对象的内存布局" class="headerlink" title="一个对象的内存布局"></a>一个对象的内存布局</h1><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><code>alloc</code> <code>init</code>分别做了些什么事？</p><p>一个类的alloc方法，会向堆申请一块区域，用来存储对象中的变量。接下来看看对象中的变量组成。</p><p>OC类会被转成struct来表示，一个NSObject转成struct是下面这个样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p>Class是一个别名，它其实是 object_class指针。</p><p>一个自定义类的表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject&#123;</span><br><span class="line"></span><br><span class="line">@public</span><br><span class="line">int _no;</span><br><span class="line">int _age;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">struct Student_IMPL &#123;</span><br><span class="line">struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">int _no;</span><br><span class="line">int _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以子类的实例变量中的第一个是父类struct表示。那么一个类分配的内存，是父类变量的内存，加上本类变量需要的内存。最顶部的NSObject中只有一个isa指针，而指针的大小与操作系统的位数有关，64位，指针也是64位，8个字节。32位，指针也是32位，4个字节。以64位系统为例，NSObject的对象会占用8个字节。Student会占用16个字节。</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>一个对象占用的内存，并不是所有变量相加出来的结果。中间会有一些空位补0，来对齐。目的是为了提高内存的访问效率以及平台移植。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct StructOne &#123;</span><br><span class="line">char a;         //1字节</span><br><span class="line">double b;       //8字节</span><br><span class="line">int c;          //4字节</span><br><span class="line">short d;        //2字节</span><br><span class="line">&#125; MyStruct1;</span><br><span class="line"></span><br><span class="line">struct StructTwo &#123;</span><br><span class="line">double b;       //8字节</span><br><span class="line">char a;         //1字节</span><br><span class="line">short d;        //2字节</span><br><span class="line">int c;         //4字节</span><br><span class="line">&#125; MyStruct2;</span><br><span class="line">NSLog(@&quot;%lu---%lu--&quot;, sizeof(MyStruct1), sizeof(MyStruct2));</span><br><span class="line">//24,16</span><br></pre></td></tr></table></figure><p>两个结构体中的组成一样，内存占用却不一样。先看下原则</p><p>内存对齐原则：</p><ul><li>对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍</li><li>结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍</li><li>如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型</li></ul><p>在不设置pragma pack的情况下，我们用前两条原则，对上面两个结构体进行分析。<br>StructOne</p><ul><li>a字段从0起，占一个字节，offset1</li><li>b字段不能从2起，按照原则1，要从8开始，占8个字节，offset 16</li><li>c字段从16起，没有问题，占4个字节，offset 20</li><li>d字段从20起，没有问题，占2个字节，offset 22</li><li>根据原则2，structOne的占位应该是double类型的整数倍，22最近的8的倍数，即24。</li></ul><p>-&gt;操作<br>地址操作，通过</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="内存bug调试，zombie模式，address-sanitizer，instruments"><a href="#内存bug调试，zombie模式，address-sanitizer，instruments" class="headerlink" title="内存bug调试，zombie模式，address sanitizer，instruments"></a>内存bug调试，zombie模式，address sanitizer，instruments</h2><p>待了解：<br><a href="https://developer.apple.com/videos/play/wwdc2018/416/" target="_blank" rel="noopener">iOS Memory Deep Dive</a></p><p>补充：<br>NSNumber，NSDate 使用taggedPointer技术，将指针与值保存在一起。看似对象，其实是基础类型。存在栈中，不会放到堆上。</p><p>参考文档：</p><p><a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;iOS 启动，会先在内存空间中开辟一块区域，然后将这块区域内部划分成如下部分。&lt;/p&gt;
&lt;img src=&quot;/2019/03/23/iOS内
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
      <category term="内存" scheme="http://yoursite.com/categories/iOS/%E5%86%85%E5%AD%98/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
